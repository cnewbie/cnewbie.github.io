{"pages":[{"title":"About","text":"About code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} About About About Nothing!!!","tags":"Tech","url":"https://cnewbie.github.io/pages/about.html"},{"title":"MySQL","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} 基础语法 高级语法 SQL 函数 教程地址 SQL语句对大小写不敏感 基础语法 SELECT 列名称 FROM 表名称 DISTINCT 用语返回唯一的值 SELECT DISTINCT 列名称 FROM 表名称 WHERE 有条件从表中选取数据 SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 操作符 描述 = 等于 <> 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 AND 和 OR 运算符是基于一个以上条件对记录进行过滤 ORDER BY 语句用于对结果集进行\b升序排序,如降序进行排序，可以使用 DESC 关键字 INSERT INTO 向表格中插入新的行 INSERT INTO 表名称 VALUES (值1,值2,…) INSERT INTO 表名称 (列1,列2,…) VALUES (值1,值2,…) UPDATE \b修改表中的数据 UPDATE 表名称 SET 列名称=新值 WHERE 列名称=新值 DELETE 删除表中的行 DELETE FROM 表名称 WHERE 列名称=值 高级语法 LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式（\"%\" 可用于定义通配符） SELECT 列名称 FROM 表名称 WHERE 列名称 LIKE 模式 % 替代一个或多个字符 _ 仅替代一个字符 [charlist] 字符列中的任何单一字符 [&#94;charlist] [!charlist] 不在字符列中的任何单一字符 IN 操作符允许我们在 WHERE 子句中规定多个值 SELECT 列名称 FROM 表名称 WHERE 列名称 IN (值1,值2,…) BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于两个值之间的数据范围 SELECT 列名称 FROM 表名称 WHERE 列名称 BETWEEN 值1 AND 值2 Alias 别名 SELECT 列名称 FROM 表名称 AS 别名 SELECT 列名称 AS 别名 FROM 表名 JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据 SELECT A.a, A.b, B.a FROM A JOIN B ON A.id=B.id JOIN : 如果表中有至少一个匹配，则返回行 LEFT JOIN : 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN : 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN : 只要其中一个表中存在匹配，就返回行 UNION 操作符用于合并两个或多个 SELECT 语句的结果集 UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL SELECT 列名 FROM 表名 UNION SELECT 列名 FROM 表名 SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中 SELECT 列名 INTO 新表名 FROM 旧表名 CREATE DATABASE 用于创建数据库 CREATE DATABASE 数据库名 CREATE TABLE 语句用于创建数据库中的表 CREATE TABLE 表名 (列名 类型,列名 类型); SQL 约束用于限制加入表的数据的类型 NOT NULL 约束强制列不接受 NULL 值 UNIQUE 约束唯一标识数据库表中的每条记录 PRIMARY KEY 主键必须包含唯一的值,主键列不能包含 NULL 值 FOREIGN KEY 指向另一个表中的 PRIMARY KEY ,约束用于预防破坏表之间连接的动作 CHECK 约束用于限制列中的值的范围 DEFAULT 约束用于向列中插入默认值 CREATE INDEX 语句用于在表中创建索引 CREATE INDEX 索引名 ON 表名(列名) DROP 语句，可以轻松地删除索引、表和数据库 DROP INDEX 列名.索引名 DROP TABLE 表名 DROP DATABASE 库名 删除表内数据，不删除表本身 TRUNCATE TABLE 表名称 ALTER TABLE 语句用于在已有的表中添加、修改或删除列 ALTER TABLE \b表名 ADD 列名 类型 ALTER TABLE 表名 ALTER COLUMN 列名 类型 ALTER TABLE 表名 DROP COLUMN 列名 AUTO INCREMENT 在新记录插入表中时生成一个唯一的数字 SQL VIEW 视图是可视化的表 CREATE VIEW 图名 AS SELECT 列名 FROM 表名 WHERE 条件 CREATE OR REPLACE VIEW 图名 AS SELECT 列名 FROM \b表名 WHERE 条件 DROP VIEW 图名 SQL Date 函数 函数 描述 NOW() 返回当前的日期和时间 CURDATE() 返回当前的日期 CURTIME() 返回当前的时间 DATE() 提取日期或日期/时间表达式的日期部分 EXTRACT() 返回日期/时间按的单独部分 DATE_ADD() 给日期添加指定的时间间隔 DATE_SUB() 从日期减去指定的时间间隔 DATEDIFF() 返回两个日期之间的天数 DATE_FORMAT() 用不同的格式显示日期/时间 NULL 值是遗漏的未知数据 MySQL 数据类型(文本、数字和日期/时间类型) SQL 函数 Aggregate 函数 Scalar 函数 \b > SELECT funCtion(列) FROM 表 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组 SELECT 列名,function() FROM 表名 WHERE 列名 GROUP BY 列名 HAVING 增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用 SELECT 列名,function() FROM 表名 WHERE 列名 GROUP BY 列名 HAVING function() 关键字索引Reference","tags":"Tech","url":"https://cnewbie.github.io/blog/2019/mysql/"},{"title":"Tmux","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} man tmux Cheat Sheet Reference man tmux options description -2 强制假设tmux支持256色 -C 启动 control mode -CC 关闭回显 -c 使用默认 shell 执行指令 -f 指定加载配置文件 -l 加载login shell配置 -L tmux 保存服务socket至 TMUX_TMPDIR，如果变量未设置则保存至/tmp 文件夹 -S 指定服务socket路径 -u 在tmux启东市查找 LC_AlL,LC_CTYPE,LANG三个环境变量，如果存在 UTF8标志则支持UTF8编码 -v 展示详细日志记录 Cheat Sheet Ctrl+b // 激活控制台；此时以下按键生效 快捷键 含义 系统操作 ? 列出所有快捷键； q 键返回 d 脱离当前会话；返回 shell 界面，输入 tmux attach 重新进入会话 D 选择要脱离的会话；同时开启多个会话使用 L 切换至上一个连接的会话 Ctrl+z 挂起当前会话 r 强制重绘连接的会话 s 选择并切换会话；在同时开启了多个会话时使用 t 显示时间信息 ( 切换至前一个会话 ) 切换至后一个回话 : 进入命令行模式 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ] 粘贴最近的\b拷贝缓存区内容 ~ 列出提示信息缓存 # 列出所有剪切版缓存 - 删除最近的拷贝缓存区内容 窗口操作 c 创建新窗口 & 关闭当前窗口 0-9 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口 . 修改当前窗口编号 f 在所有窗口中查找指定文本 i 显示当前窗口信息 面板操作 m 标记当前面板 M 清除标记的面板 \" 分隔为上下面板 % 分隔为左右面板 x 关闭当前面板 ; 切换至前一个活动面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换 q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Alt+n 切换到下一窗口 Alt+p 切换到上一个窗口 Ctrl+o 顺时针旋转当前窗口的面板 z 切换当前面板缩放状态 Reference man tmux","tags":"Tech","url":"https://cnewbie.github.io/blog/2019/tmux/"},{"title":"Sort Algorithms","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} a.sourceLine { display: inline-block; line-height: 1.25; } a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; } a.sourceLine:empty { height: 1.2em; } .sourceCode { overflow: visible; } code.sourceCode { white-space: pre; position: relative; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { code.sourceCode { white-space: pre-wrap; } a.sourceLine { text-indent: -1em; padding-left: 1em; } } pre.numberSource a.sourceLine { position: relative; left: -4em; } pre.numberSource a.sourceLine::before { content: attr(title); position: relative; left: -1em; text-align: right; vertical-align: baseline; border: none; pointer-events: all; display: inline-block; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; padding: 0 4px; width: 4em; color: #aaaaaa; } pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; } div.sourceCode { } @media screen { a.sourceLine::before { text-decoration: underline; } } code span.al { color: #ff0000; font-weight: bold; } /* Alert */ code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */ code span.at { color: #7d9029; } /* Attribute */ code span.bn { color: #40a070; } /* BaseN */ code span.bu { } /* BuiltIn */ code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */ code span.ch { color: #4070a0; } /* Char */ code span.cn { color: #880000; } /* Constant */ code span.co { color: #60a0b0; font-style: italic; } /* Comment */ code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */ code span.do { color: #ba2121; font-style: italic; } /* Documentation */ code span.dt { color: #902000; } /* DataType */ code span.dv { color: #40a070; } /* DecVal */ code span.er { color: #ff0000; font-weight: bold; } /* Error */ code span.ex { } /* Extension */ code span.fl { color: #40a070; } /* Float */ code span.fu { color: #06287e; } /* Function */ code span.im { } /* Import */ code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */ code span.kw { color: #007020; font-weight: bold; } /* Keyword */ code span.op { color: #666666; } /* Operator */ code span.ot { color: #007020; } /* Other */ code span.pp { color: #bc7a00; } /* Preprocessor */ code span.sc { color: #4070a0; } /* SpecialChar */ code span.ss { color: #bb6688; } /* SpecialString */ code span.st { color: #4070a0; } /* String */ code span.va { color: #19177c; } /* Variable */ code span.vs { color: #4070a0; } /* VerbatimString */ code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */ 工具函数 Bubble Sort 冒泡排序 Cocktail Sort 鸡尾酒排序 Selection Sort 选择排序 Insertion Sort 插入排序 Shell Sort 希尔排序 Merge Sort归并排序 Qucik Sort 快速排序 Heap Sort 堆排序 Counting Sort 计数排序 算法对比 引用 工具函数 #include <iostream> #include <ctime> using namespace std; void swap( int &a, int &b){ int tmp = a; a = b; b = tmp; } void printarr( int *a, int n){ for ( size_t i = 0 ; i < n; i++) { cout << a[i] << \" \" ; } cout << endl; } Bubble Sort 冒泡排序 void bubble_sort( int *a, int n){ for ( size_t i = n- 1 ; i > 0 ;--i){ for ( size_t j = i; j > 0 ;--j) { if (a[j] < a[j- 1 ]) swap(a[j],a[j- 1 ]); } } } void bubble_sort_speedup( int *a, int n){ for ( size_t i = 0 ; i < n- 1 ; i++){ int flag = 0 ; for ( size_t j = 0 ; j < n- 1 -i; ++j){ if (a[j] > a[j+ 1 ]){ swap(a[j],a[j+ 1 ]); flag = 1 ; } } if (!flag) break ; } } Cocktail Sort 鸡尾酒排序 void cocktail_sort( int *a, int n){ int left = 0 ; int right = n- 1 ; while (left < right){ for ( size_t i = left; i<right;++i){ if (a[i] > a[i+ 1 ]) swap(a[i],a[i+ 1 ]); } right--; for ( size_t j = right;j>left;--j){ if (a[j- 1 ] > a[j]){ swap(a[j- 1 ],a[j]); } } left++; } } void cocktail_sort_speedup( int *a, int n){ bool sorted = false ; while (!sorted){ sorted = true ; for ( int i = 0 ; i < n - 1 ; i++ ){ if ( a[i] > a[i + 1 ] ){ swap( a[i], a[i + 1 ] ); sorted = false ; } } if (sorted) break ; sorted = true ; for ( int j = n - 1 ; j > 0 ; j-- ){ if ( a[j - 1 ] > a[j] ){ swap( a[j], a[j - 1 ] ); sorted = false ; } } } } Selection Sort 选择排序 void selection_sort( int *a, int n){ for ( size_t i = 0 ;i < n- 1 ;i++){ int index = i; for ( size_t j = i+ 1 ;j < n;j++){ if (a[j] < a[index]) index = j; } if (i!=index) swap(a[i],a[index]); } } Insertion Sort 插入排序 void insertion_sort( int *a, int n){ for ( size_t i = 1 ;i < n;i++){ int tmp = a[i]; size_t j = i; while (j > 0 && tmp < a[j- 1 ]){ a[j] = a[j- 1 ]; --j; } a[j] = tmp; } } Shell Sort 希尔排序 void shell_sort( int *a, int n){ int h,i,j,t; for (h = n;h/= 2 ;){ // iterator for (i=h;i<n;i++){ t=a[i]; for (j=i;j>=h && t<a[j-h];j-=h){ a[j] = a[j-h]; } a[j] = t; } } } void shell_sort_speedup( int *a, int n){ int i,j,tmp,step; step = n; while (step> 1 ){ step = step/ 3 + 1 ; // insert sort for (i=step;i<n;i++){ tmp = a[i]; for (j=i;j> 0 && a[j] < a[j-step];j-=step){ a[j] = a[j-step]; } a[j] = tmp; } } } Merge Sort归并排序 递归版本 void merge_arr( int *a, int m, int n){ int i,j,k; int *temp = new int [n]; // 0 ---> n for (i= 0 ,j=m,k= 0 ;k<n;k++){ temp[k] = j == n ? a[i++]:i == m ? a[j++]:a[j] < a[i]? a[j++]:a[i++]; } for (k= 0 ;k<n;k++){ a[k] = temp[k]; } delete [] temp; } void merge_sort( int *a, int n){ if (n < 2 ) return ; int m = n/ 2 ; merge_sort(a,m); merge_sort(a+m,n-m); merge_arr(a,m,n); } 非递归版本 void merge_arr2( int *a, int left, int mid, int right){ int i = left; int j = mid + 1 ; int k = 0 ; int len = right-left+ 1 ; int *temp = new int [len]; // while(i <= mid && j <= right){ // temp[k++] = a[i] <= a[j] ? a[i++] : a[j++]; // } // while(i <= mid){ // temp[k++] = a[i++]; // } // while(j <= right){ // temp[k++] = a[j++]; // } for (;k<len;k++){ temp[k] = j > right? a[i++]:i > mid? a[j++]:a[i] < a[j]? a[i++]:a[j++]; } for (k = 0 ; k< len;){ a[left++] = temp[k++]; } delete [] temp; } void merge_sort( int *a, int len){ // int left,mid,right,n; int left,n; for ( int i = 2 ;i/ 2 < len;i*= 2 ){ // left = 0; // for(left=0;left+i<len;){ // mid = left + i - 1; // right = mid + i < len ? mid + i : len - 1; // n = mid + i < len ? 2*i : len - left+1; // merge_arr(a+left,mid,n); // left = right + 1 ; // } for (left = 0 ;left < len;left+=i){ // mid = left + i/2; n = left + i < len?i:len-left; merge_arr(a+left,i/ 2 ,n); } } } Qucik Sort 快速排序 void quick_sort( int *a, int len){ if (len< 2 ) return ; int i,j; int pivot = a[len/ 2 ]; for (i= 0 ,j=len- 1 ;;i++,j--){ while (a[i] < pivot) i++; while (a[j] > pivot) j--; if (i >= j) break ; // swap value swap(a[i],a[j]); } quick_sort(a,i); quick_sort(a+i,len-i); } void quick_sort2( int *a, int n){ if (n< 2 ) return ; int mid=a[ 0 ]; // pivot int i= 0 ,j=n- 1 ; while (i<j){ while (j>i && a[j]>=mid) j--; if (j>i){ a[i]=a[j]; i++; } while (i<j && a[i]<mid) i++; if (i<j){ a[j]=a[i]; j--; } } a[i]=mid; quick_sort2(a,i); quick_sort2(a+i+ 1 ,n-i- 1 ); } Heap Sort 堆排序 递归版本 // i is index of array,the left child index is 2*i+1,the right one is 2*i+2,the father index is floor((i-1)/2) void siftDown( int *a, int i, int n) { int lhs= 2 *i+ 1 ; int rhs= 2 *i+ 2 ; int maxid=i; if (lhs<n && a[maxid]<a[lhs]) maxid=lhs; if (rhs<n && a[maxid]<a[rhs]) maxid=rhs; if (maxid!=i) { swap(a[i],a[maxid]); siftDown(a,maxid,n); } } // void makeHeap(int *a, int n){ // for(int i=n/2-1; i>=0; i--) // { // siftDown(a,i,n); // } // } void heap_sort( int *a, int n){ // makeHeap(a,n); for ( int i=n/ 2 - 1 ; i>= 0 ; i--){ siftDown(a,i,n); } for ( int i=n- 1 ; i> 0 ; i--){ swap(a[ 0 ],a[i]); siftDown(a, 0 ,i); } } 非递归版本 void heap_down( int *a, int i, int n){ int lc = 2 *i+ 1 ; for (;lc<n;i=lc,lc= 2 *i+ 1 ){ // lc + 1 < n right chid index can't greater than the array length if (lc+ 1 < n && a[lc]<a[lc+ 1 ]) lc++; if (a[i] >= a[lc]) break ; else swap(a[i],a[lc]); } } void heap_sort2( int *a, int n){ // makeHeap(a,n); for ( int i=n/ 2 - 1 ; i>= 0 ; i--){ heap_down(a,i,n); } for ( int i=n- 1 ; i> 0 ; i--){ swap(a[ 0 ],a[i]); heap_down(a, 0 ,i); } } Counting Sort 计数排序 void couting_sort( int *a, int n){ int range = 20 ; int *C = new int [range]; int *temp = new int [n]; for ( int i = 0 ;i < range;i++){ C[i] = 0 ; if (i<n) temp[i]= 0 ; } for ( int j = 0 ;j < n;j++){ C[a[j]]++; } for ( int i = 1 ;i < range;i++){ C[i]+=C[i- 1 ]; } for ( int j = n- 1 ;j >= 0 ;j--){ temp[--C[a[j]]] = a[j]; } for ( int j = 0 ; j < n; j++){ a[j] = temp[j]; } delete [] C; delete [] temp; } 算法对比 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 算法名称 时间复杂度（最好） 时间复杂度（平均） 时间复杂度（最坏） 空间复杂度 稳定性 Insertion Sort O(n) O(n&#94;2) O(n&#94;2) O(1) 稳定 Shell Sort O(n) O(n&#94;1.3) O(n&#94;2) O(1) 不稳定 Selection Sort O(n&#94;2) O(n&#94;2) O(n&#94;2) O(1) 不稳定 Heap Sort O(nlog n) O(nlog n) O(nlog n) O(1) 稳定 Bubble Sort O(n) O(n&#94;2) O(n&#94;2) O(1) 稳定 Cocktail Sort O(n) O(n&#94;2) O(n&#94;2) O(1) 稳定 Qucik Sort O(nlog n) O(nlog n) O(n&#94;2) O(nlog n)~O(n) 不稳定 Merge Sort O(nlog n) O(nlog n) O(nlog n) O(n) 稳定 Counting Sort O(n+k) O(n+k) O(n+k) O(n+k) 稳定 Bucket Sort O(n) O(n+k) O(n&#94;2) O(n+k) 稳定 Radix Sort O(n*k) O(n*k) O(n*k) O(n+k) 稳定 引用 Moondark SteveWang rosettacode 一像素","tags":"Tech","url":"https://cnewbie.github.io/blog/2018/sort-algorithms/"},{"title":"Pandoc Markdown 文档","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} a.sourceLine { display: inline-block; line-height: 1.25; } a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; } a.sourceLine:empty { height: 1.2em; } .sourceCode { overflow: visible; } code.sourceCode { white-space: pre; position: relative; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { code.sourceCode { white-space: pre-wrap; } a.sourceLine { text-indent: -1em; padding-left: 1em; } } pre.numberSource a.sourceLine { position: relative; left: -4em; } pre.numberSource a.sourceLine::before { content: attr(title); position: relative; left: -1em; text-align: right; vertical-align: baseline; border: none; pointer-events: all; display: inline-block; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; padding: 0 4px; width: 4em; color: #aaaaaa; } pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; } div.sourceCode { } @media screen { a.sourceLine::before { text-decoration: underline; } } code span.al { color: #ff0000; font-weight: bold; } /* Alert */ code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */ code span.at { color: #7d9029; } /* Attribute */ code span.bn { color: #40a070; } /* BaseN */ code span.bu { } /* BuiltIn */ code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */ code span.ch { color: #4070a0; } /* Char */ code span.cn { color: #880000; } /* Constant */ code span.co { color: #60a0b0; font-style: italic; } /* Comment */ code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */ code span.do { color: #ba2121; font-style: italic; } /* Documentation */ code span.dt { color: #902000; } /* DataType */ code span.dv { color: #40a070; } /* DecVal */ code span.er { color: #ff0000; font-weight: bold; } /* Error */ code span.ex { } /* Extension */ code span.fl { color: #40a070; } /* Float */ code span.fu { color: #06287e; } /* Function */ code span.im { } /* Import */ code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */ code span.kw { color: #007020; font-weight: bold; } /* Keyword */ code span.op { color: #666666; } /* Operator */ code span.ot { color: #007020; } /* Other */ code span.pp { color: #bc7a00; } /* Preprocessor */ code span.sc { color: #4070a0; } /* SpecialChar */ code span.ss { color: #bb6688; } /* SpecialString */ code span.st { color: #4070a0; } /* String */ code span.va { color: #19177c; } /* Variable */ code span.vs { color: #4070a0; } /* VerbatimString */ code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */ Philosophy 哲学 Paragraphs 段落 Headers 标题 标题风格 \bHeader identifiers 标题标识符 Block quotations 块引用 Verbatim(code) blocks 代码块 Indented code blocks 缩进代码块 Fenced code blocks 围栏代码块 Line blocks 行块 Lists 列表 Bullet lists 项目列表／无序列表 Block content In list items 列表内的块 Ordered lists 有序列表 Definition lists 列表定义 Numbered example lists 编号示例列表 Compact and loose lists 紧凑／稀疏列表 Ending a list 结束列表 Horzontal rules 水平分隔线 Tables 表格 Metadata blocks 元数据块 Backslash escapes 反斜杠转义 Inline formatting 内联样式 Emphasis 强调 Strikeout 删除线 Superscripts and subscripts 上下标 Verbatim Math 数学公式 Raw HTML Generic raw attribute LaTeX macros Links 链接 Automatic links 自动链接 Inline links 内联链接 Reference links 参考链接 Internal links 内部链接 Images 图片 Divs and Spans Footnotes 脚注 Citations 引用 Non-pandoc extensions Markdown variants Markdwon 变种 markdown_phpextra(PHP Markdown Extra) markdown_mmd(MultiMarkdown) markdown_strict(Markdown.pl) gfm(GitHub-Flavored Markdown) 常用语法高亮 引用 Philosophy 哲学 Markdown is designed to be easy to write,and,even more importantly,easy to read. A Markdown-formatted document should be publishable as-is,as plain text,without looking like it's been marked up with tags or formatting instructions. - John Gruber Paragraphs 段落 一个段落包含一行或多行文字，通过行后跟随一个或多个空白行，换行符（newlines）和空格（spaces）作用一样，如果需要\b硬换行（hard line break），在行后添加两个以上的空格。 Extension escaped_line_breaks 反斜杠（backslash）后跟随换行符也是一种硬换行 Note 在多行和表格中，这种方式是唯一的方式进行硬换行，因为表格中空格会被忽略。 Headers 标题 标题风格 两种风格的标题 Setext 和 ATX Setext 风格 A level-one header ================== A level-two header ------------------ ATX 风格 # A level-one header ## A level-two header ### A level-three header ### Extension blank_before_header 标准 Markdown 语法不需要在标题前空白行，Pandoc 需要 空白行 （除了在文档开头）。原因是可能由于自动断行后产生歧义。 I like several of their flavors of ice cream: #22, for example, and #5. Extension space_in_atx_header 大多数 Markdown 语法不需要在 # 与标题文字间添加 空格 ，但是Pandoc需要空格。 \bHeader identifiers 标题标识符 Extension header_attributes 可以标题文字后添加属性， {#identifier .class .class key=value key=value} 。本语法兼容 PHP Markdown Extra 添加的\b属性通常用于 HTML 或基于 HTML 的格式文件\b如 EPUB 。 Extension implicit_header_references Pandoc 默认为标题创建引用链接,并可直接使用,\b如果有多个相同标题，引用将指向第一个出现的标题。引用大小写不敏感。 [Header identifiers in HTML] or [Header identifiers in HTML][] or [the section on header identifiers][header identifiers in HTML] or [Header identifiers in HTML](#header-identifiers-in-html) Block quotations 块引用 Markdown 使用 email 传统引用文字， 每行前面都有一个 > 字符和一个可选空格， > 符号不需要从最左边开始，但是不应该缩进超过三个空格。 > This is a block quote. This > paragraph has two lines. > > 1. This is a list inside a block quote. > 2. Second item. lazy form,需要在块引用的第一行使用 > 符号即可。 > This is a block quote. This paragraph has two lines. > 1. This is a list inside a block quote. 2. Second item. nested quote,块引用可以多层嵌套 > This is a block quote. > > > A block quote within a block quote. Note 如果在 > 符号后跟随可选空格，这些空格将被解析为块引用的一部分而不是内容缩进，如果需要产生缩进你需要在 > 符号后输入 五个空格 Extension blank_before_blockquote 标准语法不需要在块引用前添加 空白行 ，Pandoc需要（除了文档开头），原因是自动断行造成歧义，除非指定 markdown_strict 标志，Pandoc不认为以下代码是引用嵌套。 > This is a block quote. >> Nested. Verbatim(code) blocks 代码块 Indented code blocks 缩进代码块 文本缩进四个空格或一个tab键，将被视为代码块，保留空格、换行，特殊字符不会触发样式。初始缩进 四个空格或tab 将在输出中移除。 Note 代码块中空白行不需要四个空格缩进 Fenced code blocks 围栏代码块 Extension fenced_code_blocks 除了标准缩进代码块，Pandoc支持围栏代码块，使用 ~ 符号，在代码块前后添加一行符号，后行长度至少和起始行一样。 ~~~~~ if (a > 3) { moveShip(5 * gravity, DOWN); } ~~~~~ 围栏代码块需要空白行分离周围普通文本，如果代码中包含 ~ 符号需要使用更长的波浪线行。 Extension backtick_code_blocks 同 fenced_code_blocks 使用 ` 代替 ~ 符号 Extension fenced_code_attributes 围栏代码块可附加属性 ~~~~ {#mycode .haskell .numberLines startFrom=\"100\"} qsort [] = [] qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ mycode 是标识符， haskell 和 numberLines 表示classes， startForm 属性值为100。这些属性值可以用于语法高亮 syntax highlight <pre id= \"mycode\" class= \"haskell numberLines\" startFrom= \"100\" > <code> ... </code> </pre> numberLines 将显示代码行数，以下是快捷（shortcut）形式 ~~~{.haskell} qsort [] = [] ~~~ equal ~~~haskell qsort [] = [] ~~~ 如果 fenced_code_attributes 拓展关闭，但是文本中包含属性值，这些属性将会被打印。 Line blocks 行块 Extension line_blocks 行块是一系列以垂直符 | 开头后接空格的文本行，断行、空格将被保留。用于诗词和地址。借鉴与 reStructuredText | The limerick packs laughs anatomical | In space that is quite economical. | But the good ones I've seen | So seldom are clean | And the clean ones so seldom are comical | 200 Main St. | Berkeley, CA 94718 Lists 列表 Bullet lists 项目列表／无序列表 项目列表使用项目符（ * , + , - ）开头。 * one * two * three 默认生成的项目列表紧凑，如果需要稀疏列表\b，可以在将列表项格式化为段落，在列表项之间添加空格 * one * two * three Note 列表不需要左边缘对齐，可以使用一到三个空格缩进， 项目列表符后必须有空格 Block content In list items 列表内的块 列表项可能包含多个段落或块级内容，然而后续段落必须以 空白行开头并且缩进以列表标记之后的第一个非空格内容对齐 * First paragraph. Continued. * Second paragraph. With a code block, which must be indented eight spaces: { code } Exceptin 如果列表标记后跟随缩进代码块，必须在列表标记后添加 五个空格 ，后续段落必须在列表标记的最后一个字符后 两个空格缩进 * code continuation paragraph 列表包含其他列表，前置空白行可以省略，内嵌的列表缩进必须与前一个列表标记后的第一个非空字符对齐。 * fruits + apples - macintosh - red delicious + pears + peaches * vegetables + broccoli + chard 懒式（lazily）列表可以省略行前缩进，但如果列表项存在多个段落或其他块，\b 每段的第一行需要缩进 + A lazy, lazy, list item. + Another one; this looks bad but is legal. Second paragraph of second list item. Ordered lists 有序列表 标准 Markdown 语法，序号是十进制数字后加 . 和空格 ，序号数字会被忽略。 1. one 2. two 3. three 5. one 7. two 1. three Extension fancy_lists Pandoc 允许有序列表使用大小写字母、罗马数字、阿拉伯数字标注，列表标记可能被括号包围、单独一个右括号或者句号，他们必须与列表内容间隔一个空格，如果列表标记是大写字母后接句号则\b间隔至少两个空格。 # 同样可以作为符号标记 #. one #. two Extension startnum Pandoc 同样支持自定义起始数字，以下列表数字后接右括号，从9开始，并且子列表为小写罗马数字。 9) Ninth 10) Tenth 11) Eleventh i. subone ii. subtwo iii. subthree Pandoc 将不同类型的列表标记重新开始列表，以下是建立三个列表 (2) Two (5) Three 1. Four * Five Definition lists 列表定义 Extension definition_lists Pandoc 支持定义列表，使用 PHP Markdown Extra Term 1 : Definition 1 Term 2 with *inline markup* : Definition 2 { some code, part of Definition 2 } Third paragraph of definition 2. 每行定义一个术语，后面可存在空白行，但必须存在一个或多个定义，定义始于冒号或波浪号，可能会存在缩进一两个空格。 TODO Numbered example lists 编号示例列表 Extension example_lists 特殊列表标记符 @ ，列表会依次编号横跨整个文档，后续的新列表使用 @ 标记符，会续接之前的编号 (@) My first example will be numbered (1). (@) My second example will be numbered (2). Explanation of examples. (@) My third example will be numbered (3). 编号的示例可以打标签并且在文档中引用 (@good) This is a good example. As (@good) illustrates, ... 标签可以使用任何字母数字下划线和连字符 Note 连续段落在示例列表中 必须缩进四个空格 Compact and loose lists 紧凑／稀疏列表 Pandoc 与 Markdown.pl 在\"边缘情况\"(edge cases)表现不同 + First + Second: - Fee - Fie - Foe + Third Pandoc 解释为紧凑列表（ <p> 不包围 First , Second , Third 而 Markdown 不包围 First ）因为 Third 的空格。Pandoc 遵循简单的规则：如果文本后跟随空格视为段落， Second 后没有空行后接列表视为非段落。事实上列表后接空白行是无关的。 Ending a list 结束列表 - item one - item two { my code block } Pandoc 将代码块视为第二个列表项的第二段而不是代码块 为了\"切断\"列表，可以插入不缩进的内容，如HTML注释 - item one - item two <!-- end of list --> { my code block } 你可以使用同样的方法获得两个连续的列表而不是一个 1. one 2. two 3. three <!-- --> 1. uno 2. dos 3. tres Horzontal rules 水平分隔线 一行包含三个以上 * , - , _ 字符，字符间可插入空格，视为水平分割线 * * * * --------------- Tables 表格 四种列表样式，前三种要求等宽（fixed-width）字体,最后一种可以使用等比例（proportionally spaced）字体 Extension table_captions 选择为所有4种表格提供题注。题注是以字符串Table:(或只是:)开头的段落，它将被剥离,它可能出现在表格之前或之后。 Extension simple_tables Right Left Center Default ------- ------ ---------- ------- 12 12 12 12 123 123 123 123 1 1 1 1 Table: Demonstration of simple table syntax. 表头和表行必须各自填充一行。列对齐由表头文本相对于其下方虚线的位置确定 如果虚线与右侧的表头文本齐平但在左侧超出表头，则该列右对齐 如果虚线与左侧的表头文本齐平但在右侧超出表头，则该列左对齐 如果虚线超出两侧的表头文本，则该列居中对齐。 如果虚线与两侧的表头文本齐平，则使用默认对齐方式（大多数情况是左对齐） 表格必须以空白行结束或空白行后接虚线行 如果使用虚线来结束表格，则可以省略列表头 ------- ------ ---------- ------- 12 12 12 12 123 123 123 123 1 1 1 1 ------- ------ ---------- ------- 省略标题时，根据表格主体的第一行内容确定列对齐。在上表中，列将分别为右，左，中和右对齐。 Extension multiline_tables 多行表格允许表头和表行跨越多行文本（但不支持跨越表的多个列或行的单元格） ------------------------------------------------------------- Centered Default Right Left Header Aligned Aligned Aligned ----------- ------- --------------- ------------------------- First row 12.0 Example of a row that spans multiple lines. Second row 5.0 Here's another one. Note the blank line between rows. ------------------------------------------------------------- Table: Here's the caption. It, too, may span multiple lines. 同简单列表类似，但存在以下不同 它们必须以表头文本之前的一行虚线开头（除非省略表头） 它们必须以一行虚线结束，然后是空白行 行之间必须用空行分隔 多行表可能只有一行，但该行后面应该有一个空行（然后是结束表的虚线行） Extension grid_tables : Sample grid table. +---------------+---------------+--------------------+ | Fruit | Price | Advantages | +===============+===============+====================+ | Bananas | $1.34 | - built-in wrapper | | | | - bright color | +---------------+---------------+--------------------+ | Oranges | $2.10 | - cures scurvy | | | | - tasty | +---------------+---------------+--------------------+ = 行将表头与表体分开，对于无表头可以省略。网格表的单元格可以包含任意块元素（多个段落，代码块，列表等）,不支持跨多个列或行的单元格。 通过将冒号放在表头后面的分隔线边界处，类似与 pipe tables +---------------+---------------+--------------------+ | Right | Left | Centered | +==============:+:==============+:==================:+ | Bananas | $1.34 | built-in wrapper | +---------------+---------------+--------------------+ 对于无表头，冒号位于顶行 +--------------:+:--------------+:------------------:+ | Right | Left | Centered | +---------------+---------------+--------------------+ Note Pandoc不支持具有行跨度或列跨度的网格表。这意味着Pandoc既不支持跨行的可变列数，也不支持跨列的可变行数。所有网格表在每行中必须具有相同的列数，并且每列中的行数必须相同 Extension pipe_tables | Right | Left | Default | Center | |------:|:-----|---------|:------:| | 12 | 12 | 12 | 12 | | 123 | 123 | 123 | 123 | | 1 | 1 | 1 | 1 | : Demonstration of pipe table syntax. 前后垂直符可省略，表头不能省略。 要模拟无表头表，请包含带有空白单元格的表头。由于垂直线指示列边界，因此列不需要垂直对齐 fruit| price -----|-----: apple|2.05 pear|1.37 orange|3.09 表的单元格不能包含段落和列表等块元素，也不能跨越多行。如果表包含可打印内容宽于列宽的行，则表将占用全文宽度，单元格内容将换行，相对单元格宽度由在表格表头与表格主体分隔的行中虚线数量确定。另一方面，如果没有行宽于列宽，则单元格内容将不会包裹，单元格将根据其内容确定大小 Metadata blocks 元数据块 Extension pandoc_title_block % title % author(s) (separated by semicolons) % date 解析为书目信息，而不是常规文本,如果需要不同的信息，使用空白行分离 % % Author % My title % % June 15, 2006 标题可能占用多行，但延续行必须以空格开头 % My title on multiple lines 如果文档有多个作者，则作者可能被放在具有开头空格的单独行中，或者用分号或两者分隔 % Author One Author Two % Author One; Author Two % Author One; Author Two 日期必须单独一行 所有三个元数据字段都可能包含标准内联格式（inline format）（斜体，链接，脚注等） Extension yaml_metadata_block 顶部的三个连字符 --- 和底部的三个连字符 --- 或三个点 ... 的行分隔。 YAML 元数据块可能出现在文档中的任何位置，但如果它不在文档开头，则必须以前方存在空白行 元数据可以包含列表和 YAML 对象，Pandoc 将忽略名称以下划线结尾的字段，如果两个元数据块尝试设置相同的字段，则将采用第一个块中的值。 必须遵循 YAML 转义规则,标题包含冒号，则必须引用它。垂直符 | 在缩进行的行首，该行将按字面解释，无需转义。当文本中包含空行或块级样式时，必须遵守以上规则 --- title: 'This is the title: it contains a colon' author: - Author One - Author Two tags: [nothing, nothingness] abstract: | This is the abstract. It consists of two paragraphs. ... TODO Template variables Backslash escapes 反斜杠转义 Extension all_symbols_escapable 除了代码块或内联代码之外，任何以反斜杠开头的标点符号或空格字符都将按字面处理，即使它表示格式。 *\\*hello\\** one will get <em>*hello*</em> instead of <strong>hello</strong> 转义字符 \\`*_{}[]()>#+-.! ，反斜杠转义空格被解析为不间断空格 反斜杠转义的换行符（即在行尾发生的反斜杠）被解析为硬换行。这是Markdown的\"隐形\"换行方式，和行后尾随两个空格作用相同 Note 反斜杠转义在代码块种不起作用 Inline formatting 内联样式 Emphasis 强调 单个 * 或 _ 包围文本表示斜体 This text is _emphasized with underscores_, and this is *emphasized with asterisks*. 两个 * 或 _ 包围文本表示加重／加粗 This is **strong emphasis** and __with underscores__. * 或 _ 包围\b文本中 存在空格或反斜杠转义 不会产生斜体效果 This is * not emphasized *, and \\*neither is this\\*. Extension intraword_underscores 因为 _ 有时在单词和标识符中使用，所以Pandoc不会将由字母、数字包围的名称 _ 处理为斜体，使用 * 代替 feas*ible*, not feas*able*. Strikeout 删除线 Extension strikeout 用 ~~ 开始和结束 This ~~is deleted text.~~ Superscripts and subscripts 上下标 Extension superscript subscript 通过 &#94; 字符包围上标文本来表示上标; 可以通过 〜 字符围绕下标文本来表示下标 H~2~O is a liquid. 2&#94;10&#94; is 1024. 如果上标或下标文本包含空格，则必须使用反斜杠转义这些空格 Verbatim 文本放在反引号 ` 中，默认保留所有格式 What is the difference between `>>=` and `>>` ? 如果文本中包含反引号 ` ,使用 `` 代替，包围的前后空格会被忽略 Here is a literal backtick ` ` ` `` Note 反斜杠转义在文本上下文不起作用 Extension inline_code_attributes 类似于围栏代码块 `<$>` {.haskell} Math 数学公式 Extension tex_math_dollars 两个 $ 字符之间的任何内容都将被视为TeX数学公式。开头 $ 必须在其右边有一个非空格字符，而结束 $ 必须在其左边有一个非空格字符，并且不能立即跟随一个数字。 如果由于某种原因你需要包含文本 $ 字符中，则反斜杠 \\ 转义它们. Raw HTML Extension raw_html Markdown允许您在文档中的任何位置插入原始HTML（其中<，>和＆按字面解释） Extension markdown_in_html_blocks Extension native_divs Extension native_spans Extension raw_tex LaTeX 文本 \\begin{tabular}{|l|l|}\\hline Age & Frequency \\\\ \\hline 18--25 & 15 \\\\ 26--35 & 33 \\\\ 36--45 & 22 \\\\ \\hline \\end{tabular} Generic raw attribute Extension raw_attribute 具有特殊属性的内联 spans 和围栏代码块将被解析为具有指定格式的内容 ? \\ ```{=ms} .MYMACRO blah blah \\``` LaTeX macros Extension latex_macros TODO Links 链接 Automatic links 自动链接 将 URL 或 email 放在尖括号中 <http://google.com> <sam@green.eggs.ham> Inline links 内联链接 内联链接由方括号中的链接文本组成，后跟圆括号的URL。（URL后面可以跟引号中的链接标题。） This is an [inline link](/url) , and here's [one with a title](http://fsf.org \"click here for a good time!\"). 方括号部分和圆括号部分之间不能有空格 链接文本可以包含格式，但标题 tilte 不能。 内联链接中的电子邮件地址不会被自动检测，因此必须以 mailto 为前缀 [Write me!](mailto:sam@green.eggs.ham) Reference links 参考链接 显式参考链接有两个部分，链接本身和链接定义 链接由方括号的链接文本，后跟方括号中的标签组成。 链接定义包括方括号标签，后跟 冒号和空格 ，后跟URL，以及可省略的引号或括号中的链接标签。 引用优先于链接标签 [my label 1]: /foo/bar.html \"My title, optional\" [my label 2]: /foo [my label 3]: http://fsf.org (The free software foundation) [my label 4]: /bar#special 'A title in single quotes' [my label 5]: <http://foo.bar.baz> [my label 6]: http://fsf.org \"The free software foundation\" 链接标签大小写不敏感 Here is [my link][FOO] [Foo]: /bar/baz 隐式参考链接的第二个方括号内容可以省略 See [my website][] . [my website]: http://foo.bar.baz Note 大多数 Markdown \b实现不能将参考链接嵌入列表项和块引用中，Pandoc解除了这个限制。 > My block [quote]. > > [quote]: /foo Extension shortcut_reference_links 短参考引用可以省略第二个方括号 See [my website]. [my website]: http://foo.bar.baz Internal links 内部链接 内部链接支持链接到自动生成的标题识别符 See the [Introduction](#introduction) . See the [Introduction]. [Introduction]: #introduction Images 图片 一个链接紧接着一个 ! 将被视为插入图像，链接文本将用图像替代文字 ![la lune](lalune.jpg \"Voyage to the moon\") ![movie reel] [movie reel]: movie.gif Extension implicit_figures 图像存在非空的文字出现在段落中，将渲染成图像题注 ![This is the caption](/url/of/image.png) Extension link_attributes 图片链接可以设置属性样式 An inline ![image](foo.jpg) {#id .class width=30 height=20px} and a reference ![image][ref] with attributes. [ref]: foo.jpg \"optional title\" {#id .class key=val key2=\"val 2\"} Divs and Spans Extension fenced_divs Pandoc 支持围栏 div 语法\b,连续三个冒号，后面可跟随属性样式 ::::: {#special .sidebar} Here is a paragraph. And another. ::::: 围栏 div 可以嵌套使用 ::: Warning :::::: This is a warning. ::: Danger This is a warning within a warning. ::: :::::::::::::::::: Extension bracketed_spans 行内方括号包围文字可以解释为链接，如果后面跟随属性样式将会解析为 Span 标签 [This is *some text*]{.class key=\"val\"} Footnotes 脚注 Extension footnotes Here is a footnote reference, [&#94;1] and another. [&#94;longnote] [&#94;1] : Here is the footnote. [&#94;longnote] : Here's one with multiple blocks. Subsequent paragraphs are indented to show that they belong to the previous footnote. { some.code } The whole paragraph can be indented, or just the first line. In this way, multi-paragraph footnotes work like multi-paragraph list items. This paragraph won't be part of the note, because it isn't indented. 脚注标志符可能不包含空格、tab、回车，输出时脚注会被依次编号。脚注不需要放在文档末位处，每个脚注需要使用空白行与其他内容分离 Extension inline_notes 行内脚注不能包含多段落内容 Here is an inline note.&#94;[Inlines notes are easier to write, since you don't have to pick an identifier and move down to type the note.] Citations 引用 Extension citations Pandoc 使用以下命令可以自动生成引用和参考目录 pandoc --filter pandoc-citeproc myinput.txt TODO Non-pandoc extensions 以下拓展可以默认未开启，如需使用需要在 +EXTENSION 后输入拓展名 Extension old_dashes 智能解析 - 和 -- 符号，pandoc <= 1.8.2.1, textile 输出默认选中 Extension angle_brackets_escapable 允许 < 和 > 作为转义字符 Extension lists_without_preceding_blankline 允许列表在段落后出现，没有中间空格 Extension four_space_rule 列表项后续段落需要四个空格缩进 Extension spaced_reference_links 允许参考链接的两个括号之间存在空格 Extension hard_line_breaks 段落中的所有换行符被解释为硬换行符而不是空格 Extension ignore_line_breaks 导致段落中的换行符被忽略，而不是被视为空格或硬换行符。 此选项适用于东亚语言，其中单词之间不使用空格，但文本被分为行以便于阅读。 Extension east_asian_line_breaks 同上，对于包含东亚宽字符和其他字符混合的文本，这是一个比 ignore_line_breaks 更好的选择。 Extension emoji Pandoc 解析 :smile: 为 Emoji\b 表情 Extension tex_math_single_backslash \\( \\) 和 \\[ \\] 解析为数学公式，但是会忽略转义的 \\( 和 \\[ Extension tex_math_double_backslash \\\\( \\\\) 和 \\\\[ \\\\] 解析为数学公式 Extension markdown_attribute 默认\b \bMarkdown 解析块级属性为文本内容,此拓展只解析 具有 markdown=1 标签的块属性 Extension mmd_title_block 支持 MultiMarkdown 风格的标题块,如果 pandoc_title_block 和 yaml_metadata_block 选项开启会优先于此拓展 Title: My title Author: John Doe Date: September 1, 2008 Comment: This is a sample mmd title block, with a field spanning multiple lines. Extension abbreviations 解析 PHP Markdown Extra 缩写键值,Pandoc不支持缩写，缩写键值简单跳过 * [HTML]: Hypertext Markup Language Extension autolink_bare_uris 所有绝对路径成为链接，即使没有尖括号 <...> 包围 Extension mmd_link_attributes This is a reference ![image][ref] with multimarkdown attributes. [ref]: http://path.to/image \"Image title\" width=20px height=30px id=myId class=\"myClass1 myClass2\" Extension mmd_header_identifiers Extension compact_definition_lists 兼容性定义列表，pandoc <= 1.2* Markdown variants Markdwon 变种 markdown_phpextra(PHP Markdown Extra) footnotes, pipe_tables, raw_html, markdown_attribute, fenced_code_blocks, definition_lists, intraword_underscores, header_attributes, link_attributes, abbreviations, shortcut_reference_links, spaced_reference_links. markdown_mmd(MultiMarkdown) pipe_tables, raw_html, markdown_attribute, mmd_link_attributes, tex_math_double_backslash, intraword_underscores, mmd_title_block, footnotes, definition_lists, all_symbols_escapable, implicit_header_references, auto_identifiers, mmd_header_identifiers, shortcut_reference_links, implicit_figures, superscript, subscript, backtick_code_blocks, spaced_reference_links, raw_attribute. markdown_strict(Markdown.pl) raw_html, shortcut_reference_links, spaced_reference_links. gfm(GitHub-Flavored Markdown) pipe_tables, raw_html, fenced_code_blocks, auto_identifiers, ascii_identifiers, backtick_code_blocks, autolink_bare_uris, intraword_underscores, strikeout, hard_line_breaks, emoji, shortcut_reference_links, angle_brackets_escapable. 常用语法高亮 常用语法高亮 awk bash bibtex c cpp cmake css changelog coffee diff djangotemplate dockerfile doxygen doxygenlua email erlang gcc go html haskell ini json jsp java javascript javadoc kotlin llvm latex lua makefile markdown matlab php perl postscript powershell python ruby sql sqlmysql scala scheme texinfo mandoc xml yaml zsh dot sed xorg 引用 Pandoc","tags":"Tech","url":"https://cnewbie.github.io/blog/2018/pandoc-markdown/"},{"title":"Git Cheatsheet","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} a.sourceLine { display: inline-block; line-height: 1.25; } a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; } a.sourceLine:empty { height: 1.2em; } .sourceCode { overflow: visible; } code.sourceCode { white-space: pre; position: relative; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { code.sourceCode { white-space: pre-wrap; } a.sourceLine { text-indent: -1em; padding-left: 1em; } } pre.numberSource a.sourceLine { position: relative; left: -4em; } pre.numberSource a.sourceLine::before { content: attr(title); position: relative; left: -1em; text-align: right; vertical-align: baseline; border: none; pointer-events: all; display: inline-block; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; padding: 0 4px; width: 4em; color: #aaaaaa; } pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; } div.sourceCode { } @media screen { a.sourceLine::before { text-decoration: underline; } } code span.al { color: #ff0000; font-weight: bold; } /* Alert */ code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */ code span.at { color: #7d9029; } /* Attribute */ code span.bn { color: #40a070; } /* BaseN */ code span.bu { } /* BuiltIn */ code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */ code span.ch { color: #4070a0; } /* Char */ code span.cn { color: #880000; } /* Constant */ code span.co { color: #60a0b0; font-style: italic; } /* Comment */ code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */ code span.do { color: #ba2121; font-style: italic; } /* Documentation */ code span.dt { color: #902000; } /* DataType */ code span.dv { color: #40a070; } /* DecVal */ code span.er { color: #ff0000; font-weight: bold; } /* Error */ code span.ex { } /* Extension */ code span.fl { color: #40a070; } /* Float */ code span.fu { color: #06287e; } /* Function */ code span.im { } /* Import */ code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */ code span.kw { color: #007020; font-weight: bold; } /* Keyword */ code span.op { color: #666666; } /* Operator */ code span.ot { color: #007020; } /* Other */ code span.pp { color: #bc7a00; } /* Preprocessor */ code span.sc { color: #4070a0; } /* SpecialChar */ code span.ss { color: #bb6688; } /* SpecialString */ code span.st { color: #4070a0; } /* String */ code span.va { color: #19177c; } /* Variable */ code span.vs { color: #4070a0; } /* VerbatimString */ code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */ Git 基础 基础操作 远程仓库 标签 Git 分支 分支基本操作 远程分支 Git 工具 储藏与清理 重写历史 重置对比 子模块 Git 基础 基础操作 初始化仓库 git init git clone [url] 检查文件状态 git status 跟踪文件 git add [file name] 跟踪新文件/暂存已修改文件 对比文件修改内容 git diff [file name] git diff --cached/staged [file name] 对比暂存区文件 提交更新 git commit git commit -m [message] 更新纪录 git commit -a -m [message] 跳过暂存文件步骤直接提交 移除文件 git rm [file name] 删除文件并取消跟踪 git rm --cached [file name] 取消跟踪文件 重命名文件 git mv [file name] mv old_name new_name git rm old_name git add new_name 查看提交历史 git log git log git log --pretty=format: \"%h %s\" --graph 撤销提交 git commmit --amend git rebase -i 撤销暂存文件 git reset HEAD [file name] git reset --hard [file name] 当前文件修改丢失 撤销文件修改 git checkout -- [file name] 远程仓库 查看远程仓库 git remote -v 添加远程仓库 git remote add [short name] [url] 从远程仓库获取文件 git fetch [remote name] 推送到远程分支 git push [remote name] [branch name] 查看远程仓库 git remote show [remote-name] 远程仓库重命名 git remote rename [old name] [new name] 删除远程仓库 git rm [remote name] 标签 查看标签 git tag 添加附注标签 git tag -a [tag name] -m [message] 查看标签详情 git show [tag name] 添加轻量标签 git tag [tag name] 推送标签至远程服务器 git push [remote branch name] [tag name] 推送所有标签 git push [remote branch name] --tags 特定标签上建立分支 git checkout -b [branch name] [tag name] Git 分支 分支基本操作 分支创建 git branch [branch name] 分支切换 git checkout [branch name] 查看分支历史 git log --oneline --decorate --graph --all 合并分支 git merge [branch name] 删除分支 git branch -d [branch name] 远程分支 查看远程分支 git ls-remote or git remote show [remote name] 推送分支 git push [remote] [local branch] == git push [remote] [local branch:remote branch name] 跟踪分支 git chenckout -b [branch] [remote name]/[branch] 设置上游分支 git branch -u [remote name]/[branch] 查看跟踪分支 git branch -vv 抓取分支更新 git fetch --all 删除远程分支 git push [remote] --delete [branch name] or git push [remote] :[branch naem] example 分支合并 git rebase/merge rebase 历史纪录更简洁 变基 Git 工具 引用日志 查看分支引用的历史纪录 git reflog 提交区间 双点语法,查看后者引用中特定的提交 git log [ref name1]..[ref name2] 多点语法,不包含最后引用的提交 git log refA refB &#94;refC == git log refA refB --not refC 三点语法,查看两引用的差异提交 git log [ref name1]...[ref name2] 储藏与清理 储藏工作空间 git stash save 查看储藏列表 git stash list 应用储藏 git stash apply [ref] 删除储藏 git stash drop [ref] 不储藏暂存区文件 git stash save --kep-index 应用储藏包括暂存区 git stash apply --index 储藏包含未跟踪的文件 git stash -u/--include-untracked 新建分支并应用储藏 git stash branch [nranch name] 移除为跟踪文件 git clean 移除所用文件并储藏 git stash --all 重写历史 修改最后一次提交 git commit --amend 交互式修改ref开始的所有提交 git rebase -i [ref] 批量修改提交 git filter-branch --tree-filter [command] [ref] 切换根目录 git filter-branch --subdirectory-filter [directory name] [ref] 重置对比 相反操作操作提交指针 git reset --soft HEAD~ | git commit 相反操作暂存区 git reset [file name] | git add [file name] 撤销所有修改包括工作区 git reset --hard HEAD~ 恢复暂存区文件版本其他不变 精简历史 git reset [ref] -- [file name] 切换HEAD指针不丢弃工作目录修改 git checkout [branch name] 丢弃文件修改 reset,checkout,revert git checkout -- [file name] 子模块 添加子模块 git submodule add [url] 抓取后初始化模块 git submodule init 抓取后更新子模块 git submodule update --remote 查看子模块日志 git log -p --submodule 更新合并 git submodule update --remote --merge/--rebase 检查子模块是否推送 git push --recurse-submodules=check 批量操作子模块 git submodule foreach [command]","tags":"Tech","url":"https://cnewbie.github.io/blog/2018/git-cheatsheet/"},{"title":"Iptables","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} a.sourceLine { display: inline-block; line-height: 1.25; } a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; } a.sourceLine:empty { height: 1.2em; } .sourceCode { overflow: visible; } code.sourceCode { white-space: pre; position: relative; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { code.sourceCode { white-space: pre-wrap; } a.sourceLine { text-indent: -1em; padding-left: 1em; } } pre.numberSource a.sourceLine { position: relative; left: -4em; } pre.numberSource a.sourceLine::before { content: attr(title); position: relative; left: -1em; text-align: right; vertical-align: baseline; border: none; pointer-events: all; display: inline-block; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; padding: 0 4px; width: 4em; color: #aaaaaa; } pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; } div.sourceCode { } @media screen { a.sourceLine::before { text-decoration: underline; } } code span.al { color: #ff0000; font-weight: bold; } /* Alert */ code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */ code span.at { color: #7d9029; } /* Attribute */ code span.bn { color: #40a070; } /* BaseN */ code span.bu { } /* BuiltIn */ code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */ code span.ch { color: #4070a0; } /* Char */ code span.cn { color: #880000; } /* Constant */ code span.co { color: #60a0b0; font-style: italic; } /* Comment */ code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */ code span.do { color: #ba2121; font-style: italic; } /* Documentation */ code span.dt { color: #902000; } /* DataType */ code span.dv { color: #40a070; } /* DecVal */ code span.er { color: #ff0000; font-weight: bold; } /* Error */ code span.ex { } /* Extension */ code span.fl { color: #40a070; } /* Float */ code span.fu { color: #06287e; } /* Function */ code span.im { } /* Import */ code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */ code span.kw { color: #007020; font-weight: bold; } /* Keyword */ code span.op { color: #666666; } /* Operator */ code span.ot { color: #007020; } /* Other */ code span.pp { color: #bc7a00; } /* Preprocessor */ code span.sc { color: #4070a0; } /* SpecialChar */ code span.ss { color: #bb6688; } /* SpecialString */ code span.st { color: #4070a0; } /* String */ code span.va { color: #19177c; } /* Variable */ code span.vs { color: #4070a0; } /* VerbatimString */ code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */ filter,nat,mangle 规则表 filter表 nat表 mangle表 raw表 规则链和规则 iptables编写规则 iptables常用实例备查 引用 filter,nat,mangle 规则表 filter表 数据包过滤,根据规则决定是否放行数据包（DROP,ACCEPT,REJECT,LOG） 三条规则链 INPUT 进入本地的包 FORWARD 不是本地产生且负责转发的包 OUTPUT 本地产生的包 nat表 修改数据包ip地址、端口等信息（SNAT,DNAT,MASQUERADE,REDIRECT） 三条规则链 PREROUTING 改变进入数据包的目的地址 OUTPUT 改变本地产生包的目的地址 POSTROUTING 改变发出数据包的源地址 mangle表 修改数据包的TOS，TTL及数据包的Mark 五个规则链 PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD raw表 决定数据包是否被状态跟踪机制处理 两条规则链 OUTPUT,PREROUTING 四种状态 NEW 开始一个连接 RELATED 某个已经建立的连接所建立的新连接 ESTABLISHED 发送后接到应答的数据包 INVALID 无法识别的数据包 规则链和规则 在处理各种数据包时，根据防火墙规则的不同时机，iptables供涉及5种默认规则链： INPUT 当接收到防火墙本机地址的数据包（入站）时,应用此链中的规则。。 OUTPUT 当防火墙本机向外发送数据包（出站）时，应用此链中的规则。 FORWARD 当接收到需要通过防火墙发送给其他地址的数据包（转发）时，应用此链中的规则。 PREROUTING 在对数据包作路由选择之前，应用此链中的规则，如DNAT。 POSTROUTING 在对数据包作路由选择之后，应用此链中的规则，如SNAT。 -->PREROUTING-->[ROUTE]-->FORWARD-->POSTROUTING--> mangle | mangle &#94; mangle nat | filter | nat | | | | v | INPUT OUTPUT | mangle &#94; mangle | filter | nat v ------>local------->| filter 防火墙处理数据包的方式（规则）： ACCEPT：允许数据包通过 DROP：直接丢弃数据包，不给任何回应信息 REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。 SNAT：源地址转换。在进入路由层面的route之前，重新改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将目的地址数据改写为数据发送出去时候的源地址，并发送给主机。解决内网用户用同一个公网地址上网的问题。 MASQUERADE，是SNAT的一种特殊形式，适用于像adsl这种临时会变的ip上 DNAT:目标地址转换。和SNAT相反，IP包经过route之后、出本地的网络栈之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址。 REDIRECT：是DNAT的一种特殊形式，将网络包转发到本地host上（不管IP头部指定的目标地址是啥），方便在本机做端口转发。 LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 除去最后一个LOG，前3条规则匹配数据包后，该数据包不会再往下继续匹配了，所以编写的规则顺序极其关键。 Linux数据包路由原理 数据包流程 iptables编写规则 命令格式 [-t 表名]：该规则所操作的哪个表，可以使用filter、nat等，如果没有指定则默认为filter -A：新增一条规则，到该规则链列表的最后一行 -I：插入一条规则，原本该位置上的规则会往后顺序移动，没有指定编号则为1 -D：从规则链中删除一条规则，要么输入完整的规则，或者指定规则编号加以删除 -R：替换某条规则，规则替换不会改变顺序，而且必须指定编号。 -P：设置某条规则链的默认动作 -nL：-L、-n，查看当前运行的防火墙规则列表 chain名：指定规则表的哪个链，如INPUT、OUPUT、FORWARD、PREROUTING等 [规则编号]：插入、删除、替换规则时用，–line-numbers显示号码 [-i|o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出 [-p 协议类型]：可以指定规则应用的协议，包含tcp、udp和icmp等 [-s 源IP地址]：源主机的IP地址或子网地址 [–sport 源端口号]：数据包的IP的源端口号 [-d目标IP地址]：目标主机的IP地址或子网地址 [–dport目标端口号]：数据包的IP的目标端口号 -m：extend matches，这个选项用于提供更多的匹配参数，如： -m state –state ESTABLISHED,RELATED -m tcp –dport 22 -m multiport –dports 80,8080 -m icmp –icmp-type 8 <-j 动作>：处理数据包的动作，包括ACCEPT、DROP、REJECT等 iptables常用实例备查 iptables -P INPUT DROP iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT 限制 iptables -I INPUT 1 -m state --state RELATED,ESTABLISHED -j ACCEPT 把这条语句插在input链的最前面（第一条），对状态为ESTABLISHED,RELATED的连接放行 iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 开放指定端口 iptables -I INPUT 2 -i lo -j ACCEPT 允许loopback，本地回环是主机内部发送和接收 删除 iptables -D chain number 丢弃非法连接 iptables -A INPUT -m state –state INVALID -j DROP iptables -A OUTPUT -m state –state INVALID -j DROP iptables-A FORWARD -m state –state INVALID -j DROP 日志 iptables -R INPUT 1 -p tcp --dport 22 -m limit --limit 3/minute --limit-burst 8 -j LOG Dos iptables -N syn-flood (如果您的防火墙默认配置有\" :syn-flood - [0:0] \"则不许要该项，因为重复了) iptables -A INPUT -p tcp --syn -j syn-flood iptables -I syn-flood -p tcp -m limit --limit 2/s --limit-burst 5 -j RETURN iptables -A syn-flood -j REJECT # 防止DOS太多连接进来,可以允许外网网卡每个IP最多15个初始连接,超过的丢弃 # 需要iptables v1.4.19以上版本：iptables -V iptables -A INPUT -p tcp --syn -i eth0 --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j DROP #用Iptables抵御DDOS (参数与上相同) iptables -A INPUT -p tcp --syn -m limit --limit 5/s --limit-burst 10 -j ACCEPT iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT iptables -A FORWARD -p icmp -m limit --limit 2/s --limit-burst 10 -j ACCEPT iptables -A INPUT -p icmp --icmp-type 0 -s ! 172.29.73.0/24 -j DROP 引用 Seanlook","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/iptables-firewall/"},{"title":"Introduction of Genetic Algorithm","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} Outline of GA Selection Encoding Crossover and Mutation Binary Encoding Value Encoding Tree Encoding References Outline of GA Outline of the Basic Genetic Algorithm [Start] Generate random population of n chromosomes (suitable solutions for the problem) [Fitness] Evaluate the fitness f(x) of each chromosome x in the population [New population] Create a new population by repeating following steps until the new population is complete Selection Select two parent chromosomes from a population according to their fitness (the better fitness, the bigger chance to be selected) [Crossover] With a crossover probability cross over the parents to form a new offspring (children). If no crossover was performed, offspring is an exact copy of parents. [Mutation] With a mutation probability mutate new offspring at each locus (position in chromosome). [Accepting] Place new offspring in a new population [Replace] Use new generated population for a further run of algorithm [Test] If the end condition is satisfied, stop, and return the best solution in current population [Loop] Go to step 2 Selection Roulette Wheel Selection This method have problems when the fitnesses differs very much. Rank Selection This method can lead to slower convergence, because the best chromosomes do not differ so much from other ones. Steady-state Selection Main idea of this selection is that big part of chromosomes should survive to next generation. Elitism Elitism is name of method, which first copies the best chromosome (or a few best chromosomes) to new population. The rest is done in classical way. Elitism can very rapidly increase performance of GA, because it prevents losing the best found solution. Encoding Binary Encoding Binary encoding is the most common, mainly because first works about GA used this type of encoding. Permutation Encoding Permutation encoding can be used in ordering problems, such as traveling salesman problem or task ordering problem. Permutation encoding is only useful for ordering problems. Even for this problems for some types of crossover and mutation corrections must be made to leave the chromosome consistent (i.e. have real sequence in it). Value Encoding Direct value encoding can be used in problems, where some complicated value, such as real numbers, are used. Use of binary encoding for this type of problems would be very difficult. Tree Encoding Tree encoding is used mainly for evolving programs or expressions, for genetic programming. Tree encoding is good for evolving programs. Programing language LISP is often used to this, because programs in it are represented in this form and can be easily parsed as a tree, so the crossover and mutation can be done relatively easily. Crossover and Mutation Binary Encoding Crossover Single point crossover - one crossover point is selected, binary string from beginning of chromosome to the crossover point is copied from one parent, the rest is copied from the second parent Two point crossover - two crossover point are selected, binary string from beginning of chromosome to the first crossover point is copied from one parent, the part from the first to the second crossover point is copied from the second parent and the rest is copied from the first parent Uniform crossover - bits are randomly copied from the first or from the second parent Arithmetic crossover - some arithmetic operation is performed to make a new offspring Mutation Bit inversion - selected bits are inverted ###Permutation Encoding Crossover Single point crossover - one crossover point is selected, till this point the permutation is copied from the first parent, then the second parent is scanned and if the number is not yet in the offspring it is added Mutation Order changing - two numbers are selected and exchanged Value Encoding Crossover All crossovers from binary encoding can be used Mutation Adding a small number (for real value encoding) - to selected values is added (or subtracted) a small number Tree Encoding Crossover Tree crossover - in both parent one crossover point is selected, parents are divided in that point and exchange part below crossover point to produce new offspring Mutation Changing operator, number - selected nodes are changed References Traveling Salesman Problem Genetic Algorithm","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/gentic-algorithm-en/"},{"title":"Git Pro","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} a.sourceLine { display: inline-block; line-height: 1.25; } a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; } a.sourceLine:empty { height: 1.2em; } .sourceCode { overflow: visible; } code.sourceCode { white-space: pre; position: relative; } div.sourceCode { margin: 1em 0; } pre.sourceCode { margin: 0; } @media screen { div.sourceCode { overflow: auto; } } @media print { code.sourceCode { white-space: pre-wrap; } a.sourceLine { text-indent: -1em; padding-left: 1em; } } pre.numberSource a.sourceLine { position: relative; left: -4em; } pre.numberSource a.sourceLine::before { content: attr(title); position: relative; left: -1em; text-align: right; vertical-align: baseline; border: none; pointer-events: all; display: inline-block; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; padding: 0 4px; width: 4em; color: #aaaaaa; } pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; } div.sourceCode { } @media screen { a.sourceLine::before { text-decoration: underline; } } code span.al { color: #ff0000; font-weight: bold; } /* Alert */ code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */ code span.at { color: #7d9029; } /* Attribute */ code span.bn { color: #40a070; } /* BaseN */ code span.bu { } /* BuiltIn */ code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */ code span.ch { color: #4070a0; } /* Char */ code span.cn { color: #880000; } /* Constant */ code span.co { color: #60a0b0; font-style: italic; } /* Comment */ code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */ code span.do { color: #ba2121; font-style: italic; } /* Documentation */ code span.dt { color: #902000; } /* DataType */ code span.dv { color: #40a070; } /* DecVal */ code span.er { color: #ff0000; font-weight: bold; } /* Error */ code span.ex { } /* Extension */ code span.fl { color: #40a070; } /* Float */ code span.fu { color: #06287e; } /* Function */ code span.im { } /* Import */ code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */ code span.kw { color: #007020; font-weight: bold; } /* Keyword */ code span.op { color: #666666; } /* Operator */ code span.ot { color: #007020; } /* Other */ code span.pp { color: #bc7a00; } /* Preprocessor */ code span.sc { color: #4070a0; } /* SpecialChar */ code span.ss { color: #bb6688; } /* SpecialString */ code span.st { color: #4070a0; } /* String */ code span.va { color: #19177c; } /* Variable */ code span.vs { color: #4070a0; } /* VerbatimString */ code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */ Git Basics Getting a Git Repository Recording Changes to the Repository Viewing the Commit History Undoing Things Working with Remotes Tagging Git Aliases Git Branching Branches in a Nutshell Basic Branching and Merging Branch Management Branching Workflows Remote Branches Rebasing Distributed Git Distributed Workflows Git Tools Revision Selection Commit Ranges Reference Git Basics This chapter covers every basic command. Getting a Git Repository Initialzing a Repository in an existing directory git init Cloning an existing repository git clone [url] Recording Changes to the Repository Checking the Status of Yours Files git status Tracking New Files git add [filename] Staging Modified Files git add [filename] Short Status git status -s Ignoring files .gitignore file save file patterns to match them. The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Viewing Your Staged and Unstaged Changes git status & git diff git diff --staged # see what you've staged that will go into your next commit. git diff --cached # see that you've statged so far. Committing Your Changes git commit -m 'balabala' type commit message inline Skipping the Staging Area git commit -a -m 'balabala' Git automatically stage every file that is already tracked before doing the commit,letting you skip the git add part. Removing Files git rm remove file from your tracked files ,and also removes the file from your working directory. if you modified the file and added it to the index already,you must force the removal with the -f option. another userful thing you may want to do is to keep the file in your tree but remove it from your staging area. To do this ,use the --cached option. Moving Files git mv [oldfilename] [newfilename] = mv [oldfilename] [newfilename] + git rm [newfilename] + git add [newfilename] Viewing the Commit History By default,with no arguments, git log lists the commits made in that repository in reverse chronological order - that is ,the most recent commits show up first. git log -p -[number] shows the difference introduced in each commit. git log --stat shows some abbreviated stats for each commit. git log --pretty=[online,short,full,fuller,format] option ‘format' which allows you to specify your own log output fotmat. Userful options for git log –pretty=format & Common option to git log Limiting log Output git log -Sfunction_name Options to limit the output of git log Undoing Things One of the common undos takes place when you commit too early and possibly forget to add some files or you mess up your commit message.if you want to try that commit again,you can run commit with the --amend ooption. git commit --amend This command takes your staging area and uses it for the commit. Unstaging a Staged File git reset HEAD [filename] Unmodifying a Modified File git checkout -- [filename] Working with Remotes To be able to collaborate on any Git project,you need to know how to manage your remote repositories. Showing Your Remotes git remote -v shows you the URLs that git has stored for the shortname to be used when reading and writing to that remote. Adding Remote Repositories git remote add [shortname] [url] Fetching and Pulling from your Remotes git fetch [remote-name] Pushing to Your Remotes git push [remote-name] [branch-name] Inspecting a Remote git remote show [remote-name] shows more information about a particular remote. Removing and Renaming Remotes git remote rename [old-name] [new-name] git remote remove/rm [remote-name] remove a remote Tagging Git has the ability to tag specific points in history as being important. Listing Your Tags git tag lists the tags in alphabetical order Creating Tags Git uses two main types of tags:lightweight and annotated. A loghtweight tag is very much like a branch that doesn't change - it's just a pointer to a specific commit. Annotated tags,however,are stored as full objects in the Git database.They're checksummed;contain the tagger name,email,and date;have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). Annotated Tags git tag -a [tagname] -m \"message\" Lightweight Tags git tag [tagname] Tagging Later git tag -a [tagname] [sha1code] Sharing Tags git push orign [tagname] git push orign --tags transfer all of your tags to the remote server that are not already there. Checking out Tags git checkout -b [branchname] [tagname] Git Aliases If you don't want to type the entire text of each of the Git commands,you can easily set up an alias for each command using git config . git config --global/local alias.[aliasname] [command] Git Branching Branching means you diberge from the main line of development and continue to do work without messing with that main line. Branches in a Nutshell When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged. Creating a New Branch git branch [branchname] create a new branch called testing git log --oneline --decorate shows you where rhe branch pointers are pointing. Switching Branches git checkout [branchname] this moves HEAD to point to the branch. git log --oneline --decorate --graph --all Divergent history Basic Branching and Merging Basic Branching git checkout -b [branchname] switch branch git merge [branchname] merge branch git branch -d [branchname] delete branch Basic Merging git merge [branchname] Basic Merge Conflicts Occasionally,this process doesn't go smoothly.If you changed the same part of the same file differently in the two branches you're merging together.Git hasn't automatically created a new merge commit. It has paused the process while you resolve the conflict. If you want to use a graphical tool to resolve these issues, you can run git mergetool . git mergetool Advanced Merging Branch Management The git branch command does more than just create and detele branches. git branch -v #shows the last commit on each branch. git branch --merged/nomerged # filter this list to branches git branch -d [branchname] # detele the branch and lose that work. Branching Workflows cover some common workflows that this lightweight branching makes possible. Brancheing Workflows Remote Branches Remote references are references in your remote repositories,includeing branches,tags,and so on. you can get a full list of remote references explicitly with git ls-remote [remote] or `git remote show [remote] gor remote branches as well as more information. Pushing git push [remote] [branch]/[localbranch]:[remotebranch] The next time one of yoour collaborators fetches from the server.It's important to note that when you do a fetch that brings down new remote-tracking branches,you don't qutomatically have local,editable copies of them. To merge this work into your current working branch,you can run git merge origin/[branchmane] . git checkout -b [branchname] orgin/[branchname] create local branch base on remote branch Tracking Branches git checkout --track orgin/[branchname] In fact,this is so common that there's even a shortcut for that shortcut.if the branch name you're trying to checkout doesn't exist add exactly matches a name on only one remote.Git will create a tracking branch for you. If you already have a local brach and want to set it to a remote branch you just pulled down,or want to change the upsteam branch you're tracking. git branch -u origin/[branchname] git branch -vv # show what tracking branches you have set up. git fetch --all ; git branch -vv # fetch from all your remotes Pulling git pull Deleting Remote Branches git push origin --delete [branchname] detele remote branch Rebasing In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase . The Basic Rebase rebase a branch to master git checkout [branchname] git rebase master git checkout master git merge [branchname] There is no difference in the end product of the integration,but rebasing makes for a cleaner history. Rebasing replays changes from one line of work onto another in the order they were introduced,whereas merging takes the endpoints and merges them together. More Intersting Rebases git rebase --onto master [firstbranchname] [secondbranchname] Take the second branch forgure out the patches since it diverged from the first branch ,and replay these patches in the secondbranch as if it was based directly off master branch instead. A history with a topic branch off another topic branch The Perils of Rebasing Don not rebase commits that exist outside your repository Figure Rebase vs. Merge In general the way to get the best of both worlds is to rebase local changes you've made but haven't shared yet before you puch them in order to clean up your story,but never rebase anything you've pushed somewhere. Distributed Git Git in a distributed environment as a contributor and an integretor. Distributed Workflows Integration-Mannger Workflows Integration-Manager Workflow Figure TODO Git Tools Revision Selection Short SHA-1 git log --abbrev-commit --pretty=oneline git show [shasum] Commit Ranges Double Dot This basically asks Git to resolve a range of commits that are reachable from one commit but aren't reachable from another. git log master..experiment show a log of just those commits with master..experiment — that means \"all commits reachable from experiment that aren't reachable from master. Multiple Points Git allows you to do this by using either the &#94; character or –not before any reference from which you don't want to see reachable commits. git log refA..refB git log &#94;refA refB git log refB --not refA Triple Dot specifies all the commits that are reachable by either of two references but not by both of them. git log master...experiment see what is in master or experiment but not any common references Reference Pro Git","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/git-pro-en/"},{"title":"Hello World","text":"Untitled code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} Hello World!!!","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/hello-word-en/"}]}