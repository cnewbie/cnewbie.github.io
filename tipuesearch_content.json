{"pages":[{"title":"About","text":"About Nothing!!!","tags":"Tech","url":"https://cnewbie.github.io/pages/about.html"},{"title":"Git Cheatsheet","text":"Git 基础 基础操作 初始化仓库 git init git clone [url] 检查文件状态 git status 跟踪文件 git add [file name] 跟踪新文件/暂存已修改文件 对比文件修改内容 git diff [file name] git diff --cached/staged [file name] 对比暂存区文件 提交更新 git commit git commit -m [message] 更新纪录 git commit -a -m [message] 跳过暂存文件步骤直接提交 移除文件 git rm [file name] 删除文件并取消跟踪 git rm --cached [file name] 取消跟踪文件 重命名文件 git mv [file name] mv old_name new_name git rm old_name git add new_name 查看提交历史 git log git log git log --pretty=format: \"%h %s\" --graph 撤销提交 git commmit --amend git rebase -i 撤销暂存文件 git reset HEAD [file name] git reset --hard [file name] 当前文件修改丢失 撤销文件修改 git checkout -- [file name] 远程仓库 查看远程仓库 git remote -v 添加远程仓库 git remote add [short name] [url] 从远程仓库获取文件 git fetch [remote name] 推送到远程分支 git push [remote name] [branch name] 查看远程仓库 git remote show [remote-name] 远程仓库重命名 git remote rename [old name] [new name] 删除远程仓库 git rm [remote name] 标签 查看标签 git tag 添加附注标签 git tag -a [tag name] -m [message] 查看标签详情 git show [tag name] 添加轻量标签 git tag [tag name] 推送标签至远程服务器 git push [remote branch name] [tag name] 推送所有标签 git push [remote branch name] --tags 特定标签上建立分支 git checkout -b [branch name] [tag name] Git 分支 分支基本操作 分支创建 git branch [branch name] 分支切换 git checkout [branch name] 查看分支历史 git log --oneline --decorate --graph --all 合并分支 git merge [branch name] 删除分支 git branch -d [branch name] 远程分支 查看远程分支 git ls-remote or git remote show [remote name] 推送分支 git push [remote] [local branch] == git push [remote] [local branch:remote branch name] 跟踪分支 git chenckout -b [branch] [remote name]/[branch] 设置上游分支 git branch -u [remote name]/[branch] 查看跟踪分支 git branch -vv 抓取分支更新 git fetch --all 删除远程分支 git push [remote] --delete [branch name] or git push [remote] :[branch naem] example 分支合并 git rebase/merge rebase 历史纪录更简洁 变基 Git 工具 引用日志 查看分支引用的历史纪录 git reflog 提交区间 双点语法,查看后者引用中特定的提交 git log [ref name1]..[ref name2] 多点语法,不包含最后引用的提交 git log refA refB &#94;refC == git log refA refB --not refC 三点语法,查看两引用的差异提交 git log [ref name1]...[ref name2] 储藏与清理 储藏工作空间 git stash save 查看储藏列表 git stash list 应用储藏 git stash apply [ref] 删除储藏 git stash drop [ref] 不储藏暂存区文件 git stash save --kep-index 应用储藏包括暂存区 git stash apply --index 储藏包含未跟踪的文件 git stash -u/--include-untracked 新建分支并应用储藏 git stash branch [nranch name] 移除为跟踪文件 git clean 移除所用文件并储藏 git stash --all 重写历史 修改最后一次提交 git commit --amend 交互式修改ref开始的所有提交 git rebase -i [ref] 批量修改提交 git filter-branch --tree-filter [command] [ref] 切换根目录 git filter-branch --subdirectory-filter [directory name] [ref] 重置对比 相反操作操作提交指针 git reset --soft HEAD~ | git commit 相反操作暂存区 git reset [file name] | git add [file name] 撤销所有修改包括工作区 git reset --hard HEAD~ 恢复暂存区文件版本其他不变 精简历史 git reset [ref] -- [file name] 切换HEAD指针不丢弃工作目录修改 git checkout [branch name] 丢弃文件修改 reset,checkout,revert git checkout -- [file name] 子模块 添加子模块 git submodule add [url] 抓取后初始化模块 git submodule init 抓取后更新子模块 git submodule update --remote 查看子模块日志 git log -p --submodule 更新合并 git submodule update --remote --merge/--rebase 检查子模块是否推送 git push --recurse-submodules=check 批量操作子模块 git submodule foreach [command]","tags":"Tech","url":"https://cnewbie.github.io/blog/2018/git-cheatsheet/"},{"title":"Iptables Firewall","text":"filter,nat,mangle 规则表 filter表 数据包过滤,根据规则决定是否放行数据包（DROP,ACCEPT,REJECT,LOG） 三条规则链 INPUT 进入本地的包 FORWARD 不是本地产生且负责转发的包 OUTPUT 本地产生的包 nat表 修改数据包ip地址、端口等信息（SNAT,DNAT,MASQUERADE,REDIRECT） 三条规则链 PREROUTING 改变进入数据包的目的地址 OUTPUT 改变本地产生包的目的地址 POSTROUTING 改变发出数据包的源地址 mangle表 修改数据包的TOS，TTL及数据包的Mark 五个规则链 PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD raw表 决定数据包是否被状态跟踪机制处理 两条规则链 OUTPUT,PREROUTING 四种状态 NEW 开始一个连接 RELATED 某个已经建立的连接所建立的新连接 ESTABLISHED 发送后接到应答的数据包 INVALID 无法识别的数据包 规则链和规则 在处理各种数据包时，根据防火墙规则的不同时机，iptables供涉及5种默认规则链： INPUT 当接收到防火墙本机地址的数据包（入站）时,应用此链中的规则。。 OUTPUT 当防火墙本机向外发送数据包（出站）时，应用此链中的规则。 FORWARD 当接收到需要通过防火墙发送给其他地址的数据包（转发）时，应用此链中的规则。 PREROUTING 在对数据包作路由选择之前，应用此链中的规则，如DNAT。 POSTROUTING 在对数据包作路由选择之后，应用此链中的规则，如SNAT。 -->PREROUTING-->[ROUTE]-->FORWARD-->POSTROUTING--> mangle | mangle &#94; mangle nat | filter | nat | | | | v | INPUT OUTPUT | mangle &#94; mangle | filter | nat v ------>local------->| filter 防火墙处理数据包的方式（规则）： ACCEPT：允许数据包通过 DROP：直接丢弃数据包，不给任何回应信息 REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。 SNAT：源地址转换。在进入路由层面的route之前，重新改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将目的地址数据改写为数据发送出去时候的源地址，并发送给主机。解决内网用户用同一个公网地址上网的问题。 MASQUERADE，是SNAT的一种特殊形式，适用于像adsl这种临时会变的ip上 DNAT:目标地址转换。和SNAT相反，IP包经过route之后、出本地的网络栈之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址。 REDIRECT：是DNAT的一种特殊形式，将网络包转发到本地host上（不管IP头部指定的目标地址是啥），方便在本机做端口转发。 LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 除去最后一个LOG，前3条规则匹配数据包后，该数据包不会再往下继续匹配了，所以编写的规则顺序极其关键。 Linux数据包路由原理 iptables编写规则 [-t 表名]：该规则所操作的哪个表，可以使用filter、nat等，如果没有指定则默认为filter -A：新增一条规则，到该规则链列表的最后一行 -I：插入一条规则，原本该位置上的规则会往后顺序移动，没有指定编号则为1 -D：从规则链中删除一条规则，要么输入完整的规则，或者指定规则编号加以删除 -R：替换某条规则，规则替换不会改变顺序，而且必须指定编号。 -P：设置某条规则链的默认动作 -nL：-L、-n，查看当前运行的防火墙规则列表 chain名：指定规则表的哪个链，如INPUT、OUPUT、FORWARD、PREROUTING等 [规则编号]：插入、删除、替换规则时用，--line-numbers显示号码 [-i|o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出 [-p 协议类型]：可以指定规则应用的协议，包含tcp、udp和icmp等 [-s 源IP地址]：源主机的IP地址或子网地址 [--sport 源端口号]：数据包的IP的源端口号 [-d目标IP地址]：目标主机的IP地址或子网地址 [--dport目标端口号]：数据包的IP的目标端口号 -m：extend matches，这个选项用于提供更多的匹配参数，如： -m state –state ESTABLISHED,RELATED -m tcp –dport 22 -m multiport –dports 80,8080 -m icmp –icmp-type 8 <-j 动作>：处理数据包的动作，包括ACCEPT、DROP、REJECT等 iptables常用实例备查 iptables -P INPUT DROP iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT 限制 iptables -I INPUT 1 -m state --state RELATED,ESTABLISHED -j ACCEPT 把这条语句插在input链的最前面（第一条），对状态为ESTABLISHED,RELATED的连接放行。 iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 开放指定端口 iptables -I INPUT 2 -i lo -j ACCEPT 允许loopback，本地回环是主机内部发送和接收 删除 iptables -D chain number 丢弃非法连接 iptables -A INPUT -m state –state INVALID -j DROP iptables -A OUTPUT -m state –state INVALID -j DROP iptables-A FORWARD -m state –state INVALID -j DROP 日志 iptables -R INPUT 1 -p tcp --dport 22 -m limit --limit 3/minute --limit-burst 8 -j LOG Dos iptables -N syn-flood (如果您的防火墙默认配置有\" :syn-flood - [0:0] \"则不许要该项，因为重复了) iptables -A INPUT -p tcp --syn -j syn-flood iptables -I syn-flood -p tcp -m limit --limit 2/s --limit-burst 5 -j RETURN iptables -A syn-flood -j REJECT # 防止DOS太多连接进来,可以允许外网网卡每个IP最多15个初始连接,超过的丢弃 # 需要iptables v1.4.19以上版本：iptables -V iptables -A INPUT -p tcp --syn -i eth0 --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j DROP #用Iptables抵御DDOS (参数与上相同) iptables -A INPUT -p tcp --syn -m limit --limit 5/s --limit-burst 10 -j ACCEPT iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT iptables -A FORWARD -p icmp -m limit --limit 2/s --limit-burst 10 -j ACCEPT iptables -A INPUT -p icmp --icmp-type 0 -s ! 172.29.73.0/24 -j DROP 引用 Seanlook","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/iptables-firewall/"},{"title":"Introduction of Genetic Algorithm","text":"Outline of GA Outline of the Basic Genetic Algorithm [Start] Generate random population of n chromosomes (suitable solutions for the problem) [Fitness] Evaluate the fitness f(x) of each chromosome x in the population [New population] Create a new population by repeating following steps until the new population is complete [Selection] Select two parent chromosomes from a population according to their fitness (the better fitness, the bigger chance to be selected) [Crossover] With a crossover probability cross over the parents to form a new offspring (children). If no crossover was performed, offspring is an exact copy of parents. [Mutation] With a mutation probability mutate new offspring at each locus (position in chromosome). [Accepting] Place new offspring in a new population [Replace] Use new generated population for a further run of algorithm [Test] If the end condition is satisfied, stop, and return the best solution in current population [Loop] Go to step 2 Selection Roulette Wheel Selection This method have problems when the fitnesses differs very much. Rank Selection This method can lead to slower convergence, because the best chromosomes do not differ so much from other ones. Steady-state Selection Main idea of this selection is that big part of chromosomes should survive to next generation. Elitism Elitism is name of method, which first copies the best chromosome (or a few best chromosomes) to new population. The rest is done in classical way. Elitism can very rapidly increase performance of GA, because it prevents losing the best found solution. Encoding Binary Encoding Binary encoding is the most common, mainly because first works about GA used this type of encoding. Permutation Encoding Permutation encoding can be used in ordering problems, such as traveling salesman problem or task ordering problem. Permutation encoding is only useful for ordering problems. Even for this problems for some types of crossover and mutation corrections must be made to leave the chromosome consistent (i.e. have real sequence in it). Value Encoding Direct value encoding can be used in problems, where some complicated value, such as real numbers, are used. Use of binary encoding for this type of problems would be very difficult. Tree Encoding Tree encoding is used mainly for evolving programs or expressions, for genetic programming. Tree encoding is good for evolving programs. Programing language LISP is often used to this, because programs in it are represented in this form and can be easily parsed as a tree, so the crossover and mutation can be done relatively easily. Crossover and Mutation Binary Encoding Crossover Single point crossover - one crossover point is selected, binary string from beginning of chromosome to the crossover point is copied from one parent, the rest is copied from the second parent Two point crossover - two crossover point are selected, binary string from beginning of chromosome to the first crossover point is copied from one parent, the part from the first to the second crossover point is copied from the second parent and the rest is copied from the first parent Uniform crossover - bits are randomly copied from the first or from the second parent Arithmetic crossover - some arithmetic operation is performed to make a new offspring Mutation Bit inversion - selected bits are inverted Permutation Encoding Crossover Single point crossover - one crossover point is selected, till this point the permutation is copied from the first parent, then the second parent is scanned and if the number is not yet in the offspring it is added Mutation Order changing - two numbers are selected and exchanged Value Encoding Crossover All crossovers from binary encoding can be used Mutation Adding a small number (for real value encoding) - to selected values is added (or subtracted) a small number Tree Encoding Crossover Tree crossover - in both parent one crossover point is selected, parents are divided in that point and exchange part below crossover point to produce new offspring Mutation Changing operator, number - selected nodes are changed References Traveling Salesman Problem Genetic Algorithm","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/introduction-of-genetic-algorithm-en/"},{"title":"Git Pro","text":"Git Basics This chapter covers every basic command. Getting a Git Repository Initialzing a Repository in an existing directory git init Cloning an existing repository git clone [url] Recording Changes to the Repository Checking the Status of Yours Files git status Tracking New Files git add [filename] Staging Modified Files git add [filename] Short Status git status -s Ignoring files .gitignore file save file patterns to match them. The rules for the patterns you can put in the .gitignore file are as follows: - Blank lines or lines starting with # are ignored. - Standard glob patterns work. - You can start patterns with a forward slash (/) to avoid recursivity. - You can end patterns with a forward slash (/) to specify a directory. - You can negate a pattern by starting it with an exclamation point (!). Viewing Your Staged and Unstaged Changes git status & git diff git diff --staged # see what you've staged that will go into your next commit. git diff --cached # see that you've statged so far. Committing Your Changes git commit -m 'balabala' type commit message inline Skipping the Staging Area git commit -a -m 'balabala' Git automatically stage every file that is already tracked before doing the commit,letting you skip the git add part. Removing Files git rm remove file from your tracked files ,and also removes the file from your working directory. if you modified the file and added it to the index already,you must force the removal with the -f option. another userful thing you may want to do is to keep the file in your tree but remove it from your staging area. To do this ,use the --cached option. Moving Files git mv [oldfilename] [newfilename] = mv [oldfilename] [newfilename] + git rm [newfilename] + git add [newfilename] Viewing the Commit History By default,with no arguments, git log lists the commits made in that repository in reverse chronological order - that is ,the most recent commits show up first. git log -p -[number] shows the difference introduced in each commit. git log --stat shows some abbreviated stats for each commit. git log --pretty=[online,short,full,fuller,format] option 'format' which allows you to specify your own log output fotmat. Userful options for git log --pretty=format & Common option to git log Limiting log Output git log -Sfunction_name Options to limit the output of git log Undoing Things One of the common undos takes place when you commit too early and possibly forget to add some files or you mess up your commit message.if you want to try that commit again,you can run commit with the --amend ooption. git commit --amend This command takes your staging area and uses it for the commit. Unstaging a Staged File git reset HEAD [filename] Unmodifying a Modified File git checkout -- [filename] Working with Remotes To be able to collaborate on any Git project,you need to know how to manage your remote repositories. Showing Your Remotes git remote -v shows you the URLs that git has stored for the shortname to be used when reading and writing to that remote. Adding Remote Repositories git remote add [shortname] [url] Fetching and Pulling from your Remotes git fetch [remote-name] Pushing to Your Remotes git push [remote-name] [branch-name] Inspecting a Remote git remote show [remote-name] shows more information about a particular remote. Removing and Renaming Remotes git remote rename [old-name] [new-name] git remote remove/rm [remote-name] remove a remote Tagging Git has the ability to tag specific points in history as being important. Listing Your Tags git tag lists the tags in alphabetical order Creating Tags Git uses two main types of tags:lightweight and annotated. A loghtweight tag is very much like a branch that doesn't change - it's just a pointer to a specific commit. Annotated tags,however,are stored as full objects in the Git database.They're checksummed;contain the tagger name,email,and date;have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). Annotated Tags git tag -a [tagname] -m \"message\" Lightweight Tags git tag [tagname] Tagging Later git tag -a [tagname] [sha1code] Sharing Tags git push orign [tagname] git push orign --tags transfer all of your tags to the remote server that are not already there. Checking out Tags git checkout -b [branchname] [tagname] Git Aliases If you don't want to type the entire text of each of the Git commands,you can easily set up an alias for each command using git config . git config --global/local alias.[aliasname] [command] Git Branching Branching means you diberge from the main line of development and continue to do work without messing with that main line. Branches in a Nutshell When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged. Creating a New Branch git branch [branchname] create a new branch called testing git log --oneline --decorate shows you where rhe branch pointers are pointing. Switching Branches git checkout [branchname] this moves HEAD to point to the branch. git log --oneline --decorate --graph --all Divergent history Basic Branching and Merging Basic Branching git checkout -b [ branchname ] switch branch git merge [ branchname ] merge branch git branch -d [ branchname ] delete branch Basic Merging git merge [branchname] Basic Merge Conflicts Occasionally,this process doesn't go smoothly.If you changed the same part of the same file differently in the two branches you're merging together.Git hasn't automatically created a new merge commit. It has paused the process while you resolve the conflict. If you want to use a graphical tool to resolve these issues, you can run git mergetool . git mergetool Advanced Merging Branch Management The git branch command does more than just create and detele branches. git branch -v #shows the last commit on each branch. git branch --merged/nomerged # filter this list to branches git branch -d [ branchname ] # detele the branch and lose that work. Branching Workflows cover some common workflows that this lightweight branching makes possible. Brancheing Workflows Remote Branches Remote references are references in your remote repositories,includeing branches,tags,and so on. you can get a full list of remote references explicitly with git ls-remote [remote] or `git remote show [remote] gor remote branches as well as more information. Pushing git push [remote] [branch]/[localbranch]:[remotebranch] The next time one of yoour collaborators fetches from the server.It's important to note that when you do a fetch that brings down new remote-tracking branches,you don't qutomatically have local,editable copies of them. To merge this work into your current working branch,you can run git merge origin/[branchmane] . git checkout -b [branchname] orgin/[branchname] create local branch base on remote branch Tracking Branches git checkout --track orgin/[branchname] In fact,this is so common that there's even a shortcut for that shortcut.if the branch name you're trying to checkout doesn't exist add exactly matches a name on only one remote.Git will create a tracking branch for you. If you already have a local brach and want to set it to a remote branch you just pulled down,or want to change the upsteam branch you're tracking. git branch -u origin/ [ branchname ] git branch -vv # show what tracking branches you have set up. git fetch --all ; git branch -vv # fetch from all your remotes Pulling git pull Deleting Remote Branches git push origin --delete [branchname] detele remote branch Rebasing In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase . The Basic Rebase rebase a branch to master git checkout [ branchname ] git rebase master git checkout master git merge [ branchname ] There is no difference in the end product of the integration,but rebasing makes for a cleaner history. Rebasing replays changes from one line of work onto another in the order they were introduced,whereas merging takes the endpoints and merges them together. More Intersting Rebases git rebase --onto master [firstbranchname] [secondbranchname] Take the second branch forgure out the patches since it diverged from the first branch ,and replay these patches in the secondbranch as if it was based directly off master branch instead. A history with a topic branch off another topic branch The Perils of Rebasing Don not rebase commits that exist outside your repository Figure Rebase vs. Merge In general the way to get the best of both worlds is to rebase local changes you've made but haven't shared yet before you puch them in order to clean up your story,but never rebase anything you've pushed somewhere. Distributed Git Git in a distributed environment as a contributor and an integretor. Distributed Workflows Integration-Mannger Workflows Integration-Manager Workflow Figure TODO Git Tools Revision Selection Short SHA-1 git log --abbrev-commit --pretty=oneline git show [shasum] Commit Ranges Double Dot This basically asks Git to resolve a range of commits that are reachable from one commit but aren't reachable from another. git log master..experiment show a log of just those commits with master..experiment — that means \"all commits reachable from experiment that aren't reachable from master. Multiple Points Git allows you to do this by using either the &#94; character or --not before any reference from which you don't want to see reachable commits. git log refA..refB git log &#94;refA refB git log refB --not refA Triple Dot specifies all the commits that are reachable by either of two references but not by both of them. git log master...experiment see what is in master or experiment but not any common references Reference Pro Git","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/git-pro-en/"},{"title":"Hello World","text":"Hello World!!!","tags":"Tech","url":"https://cnewbie.github.io/blog/2017/hello-world-en/"}]}