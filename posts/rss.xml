<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hugo NexT Blog</title><link>https://cnewbie.github.io/posts/</link><description>Recent content in Posts on Hugo NexT Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 18 Jan 2024 10:13:10 +0800</lastBuildDate><atom:link href="https://cnewbie.github.io/posts/rss.xml" rel="self" type="application/rss+xml"/><item><title>静态网站评论系统对比</title><link>https://cnewbie.github.io/posts/site-comment/</link><pubDate>Thu, 18 Jan 2024 10:13:10 +0800</pubDate><guid>https://cnewbie.github.io/posts/site-comment/</guid><description>静态网站评论系统对比 由于博客年久失修，很久没有产出文章了，之前的主题已经很久没有更新（自己不太会前端），突然心血来潮想要更新一下，并且增加评</description></item><item><title>Python 描述符</title><link>https://cnewbie.github.io/posts/python-description/</link><pubDate>Fri, 01 May 2020 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-description/</guid><description>Python 描述符 什么是描述符（Descriptor） 定义了 __get__(),__set__(),__delete__()中任意一个描述符协议的对象</description></item><item><title>Python 属性访问顺序</title><link>https://cnewbie.github.io/posts/python-propertyorder/</link><pubDate>Fri, 01 May 2020 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-propertyorder/</guid><description>Python 属性访问顺序 实例属性访问顺序 类的 __getattribute__() 方法 类的数据描述符：(定义了描述符方法)（若人为的重载了该 __getattribute__() 方法，可能会导致无法调用描述符） 实例的属性字</description></item><item><title>LRU 缓存淘汰策略</title><link>https://cnewbie.github.io/posts/os-lru/</link><pubDate>Mon, 30 Mar 2020 22:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/os-lru/</guid><description>LRU（Least Recent Used）缓存淘汰策略 LRU 算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几</description></item><item><title>Binary Search</title><link>https://cnewbie.github.io/posts/algorithm-binary-search/</link><pubDate>Sun, 15 Dec 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/algorithm-binary-search/</guid><description>二分查找 二分查找模版 def binary_search(arr, target): if not arr: return -1 left = 0 right = len(arr) - 1 while left &amp;lt;= right: mid = left + ((right - left)&amp;gt;&amp;gt;1) pivot = arr[mid] if pivot &amp;lt; target: left = mid + 1 elif pivot &amp;gt; target: right = mid - 1 else pass # ??? ret = -1 # ??? return ret 二</description></item><item><title>设计模式</title><link>https://cnewbie.github.io/posts/oop-design-pattern/</link><pubDate>Fri, 01 Nov 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/oop-design-pattern/</guid><description>面向对象之设计模式 创建型模式 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。 工厂方法 Factory Method 意图 父类中提供创建对象的接口，但</description></item><item><title>Python Cookbook</title><link>https://cnewbie.github.io/posts/python-cookbook/</link><pubDate>Sun, 05 May 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-cookbook/</guid><description>数据结构与算法 小顶堆 import heapq nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] heap = list(nums) heapq.heapify(heap) heap # [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] print(heapq.nlargest(3, nums)) # Prints [42, 37, 23] print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2] nlargest() 和 nsmallest() 适合查找元素数量少的情</description></item><item><title>Python 内存拷贝</title><link>https://cnewbie.github.io/posts/python-deepcopy/</link><pubDate>Thu, 25 Apr 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-deepcopy/</guid><description>Python 浅拷贝、深拷贝 深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。 等于</description></item><item><title>Python 统计代码运行时间</title><link>https://cnewbie.github.io/posts/python-code-running-time/</link><pubDate>Mon, 22 Apr 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-code-running-time/</guid><description>Python 运行时间 在很多的时候我们需要计算我们程序的性能，这个时候我们常常需要统计程序运行的时间。下面我们就来说说怎么统计程序的运行时间。 datetime #! /usr/bin/env python #</description></item><item><title>Python 装饰器</title><link>https://cnewbie.github.io/posts/python-decorator/</link><pubDate>Sat, 20 Apr 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-decorator/</guid><description>Python 装饰器 装饰器的定义 装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函</description></item><item><title>Python 闭包</title><link>https://cnewbie.github.io/posts/python-closure/</link><pubDate>Wed, 17 Apr 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-closure/</guid><description>Python 闭包 首先还得从基本概念说起，什么是闭包呢？来看下维基上的解释: 在计算机科学中，闭包（Closure）是词法闭包（Lexical Closur</description></item><item><title>类间关系</title><link>https://cnewbie.github.io/posts/oop-relationship-of-class/</link><pubDate>Mon, 15 Apr 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/oop-relationship-of-class/</guid><description>类之间的关系 泛化（Generalization） 泛化关系：是一种继承关系，表示一般与特殊的关系，通过继承增加子类的能力，它指定了子类如何特化</description></item><item><title>MySQL 命令速查</title><link>https://cnewbie.github.io/posts/database-mysql/</link><pubDate>Tue, 26 Mar 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/database-mysql/</guid><description>教程地址 SQL语句对大小写不敏感 基础语法 SELECT 列名称 FROM 表名称 DISTINCT 用语返回唯一的值 SELECT DISTINCT 列名称 FROM 表名称 WHERE 有条件从表中选取数据 SELECT 列名称 FROM 表名称 WHERE 列 运算符</description></item><item><title>Python 元类</title><link>https://cnewbie.github.io/posts/python-metaclass/</link><pubDate>Fri, 15 Mar 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/python-metaclass/</guid><description>Python 元类（metaclass） 对象 Python 中一切皆对象，连类也不例外。 对象中包含三个关键性属性： 标识 使用 id() 方法查看 对象值 类型 使用 type() 方法查看 类与对象 Python</description></item><item><title>Tmux and Screen</title><link>https://cnewbie.github.io/posts/linux-tmux/</link><pubDate>Fri, 15 Mar 2019 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/linux-tmux/</guid><description>Terminal Multiplexers: Screen, Tmux 终端多路复用：Screen，Tmux 命令行选项 术语对照表 英文 中文 session 会话 attach 连接 detach 脱离 prefix 前缀 multiplexer 多路复用 window 窗口 regions 区域 panes 面板 buffer 缓存 mark 标记 用途</description></item><item><title>常用排序算法总结</title><link>https://cnewbie.github.io/posts/algorithm-sort-algorithms/</link><pubDate>Sun, 05 Aug 2018 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/algorithm-sort-algorithms/</guid><description>工具函数 #include &amp;lt;iostream&amp;gt; #include &amp;lt;ctime&amp;gt; using namespace std; void swap(int &amp;amp;a,int &amp;amp;b){ int tmp = a; a = b; b = tmp; } void printarr(int *a,int n){ for(size_t i = 0; i &amp;lt; n; i++) { cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } Bubble Sort 冒泡排序 void bubble_sort(int *a, int n){ for(size_t i = n-1; i &amp;gt; 0;--i){ for(size_t j</description></item><item><title>Pandoc Markdown 文档</title><link>https://cnewbie.github.io/posts/markdown-pandoc/</link><pubDate>Sat, 04 Aug 2018 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/markdown-pandoc/</guid><description>Philosophy 哲学 Markdown is designed to be easy to write,and,even more importantly,easy to read. A Markdown-formatted document should be publishable as-is,as plain text,without looking like it&amp;rsquo;s been marked up with tags or formatting instructions. - John Gruber Paragraphs 段落 一个段落包含一行或多行文字，通过行后跟随一个或多个空白行，</description></item><item><title>Git 命令速查</title><link>https://cnewbie.github.io/posts/tools-git/</link><pubDate>Mon, 16 Jul 2018 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/tools-git/</guid><description>Git 基础 基础操作 初始化仓库 git init git clone [url] 检查文件状态 git status 跟踪文件 git add [file name] 跟踪新文件/暂存已修改文件 对比文件修改内容 git diff [file name] git diff --cached/staged [file name] 对比暂存区文件</description></item><item><title>Iptables 配置</title><link>https://cnewbie.github.io/posts/linux-iptables/</link><pubDate>Mon, 16 Jul 2018 08:00:00 +0800</pubDate><guid>https://cnewbie.github.io/posts/linux-iptables/</guid><description>filter,nat,mangle 规则表 filter表 数据包过滤,根据规则决定是否放行数据包（DROP,ACCEPT,REJECT,LOG） 三条规则链 INPUT 进入本地的包 FORWARD 不是本</description></item><item><title>Introduction of Genetic Algorithm</title><link>https://cnewbie.github.io/posts/algorithm-ga-en/</link><pubDate>Wed, 12 Apr 2017 08:36:54 +0800</pubDate><guid>https://cnewbie.github.io/posts/algorithm-ga-en/</guid><description>Outline of GA Outline of the Basic Genetic Algorithm
[Start] Generate random population of n chromosomes (suitable solutions for the problem)
[Fitness] Evaluate the fitness f(x) of each chromosome x in the population
[New population] Create a new population by repeating following steps until the new population is complete
[Selection] Select two parent chromosomes from a population according to their fitness (the better fitness, the bigger chance to be selected)</description></item></channel></rss>